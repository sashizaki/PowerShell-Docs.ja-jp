---
ms.date: 09/13/2016
ms.topic: reference
title: 強くお勧めする開発ガイドライン
description: 強くお勧めする開発ガイドライン
ms.openlocfilehash: e12fa0d1adc0d7a0dad938457bdcd289736df97c
ms.sourcegitcommit: ba7315a496986451cfc1296b659d73ea2373d3f0
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/10/2020
ms.locfileid: "93355240"
---
# <a name="strongly-encouraged-development-guidelines"></a><span data-ttu-id="11ce0-103">強くお勧めする開発ガイドライン</span><span class="sxs-lookup"><span data-stu-id="11ce0-103">Strongly Encouraged Development Guidelines</span></span>

<span data-ttu-id="11ce0-104">このセクションでは、コマンドレットを記述するときに従う必要があるガイドラインについて説明します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-104">This section describes guidelines that you should follow when you write your cmdlets.</span></span> <span data-ttu-id="11ce0-105">コマンドレットを設計するためのガイドラインと、コマンドレットコードを記述するためのガイドラインに分けられています。</span><span class="sxs-lookup"><span data-stu-id="11ce0-105">They are separated into guidelines for designing cmdlets and guidelines for writing your cmdlet code.</span></span> <span data-ttu-id="11ce0-106">これらのガイドラインは、すべてのシナリオに適用できるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="11ce0-106">You might find that these guidelines are not applicable for every scenario.</span></span> <span data-ttu-id="11ce0-107">ただし、これらのガイドラインに従っていない場合は、コマンドレットを使用すると、ユーザーのエクスペリエンスが低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-107">However, if they do apply and you do not follow these guidelines, your users might have a poor experience when they use your cmdlets.</span></span>

## <a name="design-guidelines"></a><span data-ttu-id="11ce0-108">設計ガイドライン</span><span class="sxs-lookup"><span data-stu-id="11ce0-108">Design Guidelines</span></span>

<span data-ttu-id="11ce0-109">コマンドレットとその他のコマンドレットを使用して一貫したユーザーエクスペリエンスを実現するために、コマンドレットを設計するときは、次のガイドラインに従う必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-109">The following guidelines should be followed when designing cmdlets to ensure a consistent user experience between using your cmdlets and other cmdlets.</span></span> <span data-ttu-id="11ce0-110">状況に当てはまる設計ガイドラインが見つかったら、同様のガイドラインのコードガイドラインを確認してください。</span><span class="sxs-lookup"><span data-stu-id="11ce0-110">When you find a Design guideline that applies to your situation, be sure to look at the Code guidelines for similar guidelines.</span></span>

### <a name="use-a-specific-noun-for-a-cmdlet-name-sd01"></a><span data-ttu-id="11ce0-111">コマンドレット名に特定の名詞を使用する (SD01)</span><span class="sxs-lookup"><span data-stu-id="11ce0-111">Use a Specific Noun for a Cmdlet Name (SD01)</span></span>

<span data-ttu-id="11ce0-112">コマンドレットの名前付けで使用される名詞は、ユーザーがコマンドレットを検出できるように、非常に固有である必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-112">Nouns used in cmdlet naming need to be very specific so that the user can discover your cmdlets.</span></span>
<span data-ttu-id="11ce0-113">"Server" などの汎用名詞を製品名の短縮版にプレフィックスとして使用します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-113">Prefix generic nouns such as "server" with a shortened version of the product name.</span></span> <span data-ttu-id="11ce0-114">たとえば、名詞が Microsoft SQL Server のインスタンスを実行しているサーバーを参照している場合は、"SQLServer" などの名詞を使用します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-114">For example, if a noun refers to a server that is running an instance of Microsoft SQL Server, use a noun such as "SQLServer".</span></span> <span data-ttu-id="11ce0-115">特定の名詞と承認された動詞の短いリストを組み合わせることにより、ユーザーはコマンドレット名間の重複を回避しながら、機能を迅速に検出して予測することができます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-115">The combination of specific nouns and the short list of approved verbs enable the user to quickly discover and anticipate functionality while avoiding duplication among cmdlet names.</span></span>

<span data-ttu-id="11ce0-116">ユーザーエクスペリエンスを向上させるために、コマンドレット名に対して選択する名詞は単数形にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-116">To enhance the user experience, the noun that you choose for a cmdlet name should be singular.</span></span> <span data-ttu-id="11ce0-117">たとえば、Get プロセスではなく名前を使用し `Get-Process` ます。 </span><span class="sxs-lookup"><span data-stu-id="11ce0-117">For example, use the name `Get-Process` instead of **Get-Processes**.</span></span> <span data-ttu-id="11ce0-118">コマンドレットが複数の項目に対して動作する可能性が高い場合でも、すべてのコマンドレット名に対してこの規則に従うことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="11ce0-118">It is best to follow this rule for all cmdlet names, even when a cmdlet is likely to act upon more than one item.</span></span>

### <a name="use-pascal-case-for-cmdlet-names-sd02"></a><span data-ttu-id="11ce0-119">コマンドレット名に Pascal ケースを使用する (SD02)</span><span class="sxs-lookup"><span data-stu-id="11ce0-119">Use Pascal Case for Cmdlet Names (SD02)</span></span>

<span data-ttu-id="11ce0-120">パラメーター名には Pascal 形式を使用します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-120">Use Pascal case for parameter names.</span></span> <span data-ttu-id="11ce0-121">つまり、動詞の最初の文字と名詞で使用されるすべての用語を大文字にします。</span><span class="sxs-lookup"><span data-stu-id="11ce0-121">In other words, capitalize the first letter of verb and all terms used in the noun.</span></span> <span data-ttu-id="11ce0-122">(例: "`Clear-ItemProperty`")。</span><span class="sxs-lookup"><span data-stu-id="11ce0-122">For example, "`Clear-ItemProperty`".</span></span>

### <a name="parameter-design-guidelines-sd03"></a><span data-ttu-id="11ce0-123">パラメーターのデザインガイドライン (SD03)</span><span class="sxs-lookup"><span data-stu-id="11ce0-123">Parameter Design Guidelines (SD03)</span></span>

<span data-ttu-id="11ce0-124">コマンドレットには、操作が必要なデータを受け取るパラメーターと、操作の特性を決定するために使用される情報を示すパラメーターが必要です。</span><span class="sxs-lookup"><span data-stu-id="11ce0-124">A cmdlet needs parameters that receive the data on which it must operate, and parameters that indicate information that is used to determine the characteristics of the operation.</span></span> <span data-ttu-id="11ce0-125">たとえば、コマンドレットにはパイプラインからデータを受け取るパラメーターがあり、コマンドレットには、 `Name` `Force` コマンドレットが強制的に操作を実行できることを示すパラメーターがある場合があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-125">For example, a cmdlet might have a `Name` parameter that receives data from the pipeline, and the cmdlet might have a `Force` parameter to indicate that the cmdlet can be forced to perform its operation.</span></span> <span data-ttu-id="11ce0-126">コマンドレットで定義できるパラメーターの数に制限はありません。</span><span class="sxs-lookup"><span data-stu-id="11ce0-126">There is no limit to the number of parameters that a cmdlet can define.</span></span>

#### <a name="use-standard-parameter-names"></a><span data-ttu-id="11ce0-127">標準パラメーター名を使用する</span><span class="sxs-lookup"><span data-stu-id="11ce0-127">Use Standard Parameter Names</span></span>

<span data-ttu-id="11ce0-128">コマンドレットでは、ユーザーが特定のパラメーターの意味をすばやく判断できるように、標準のパラメーター名を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-128">Your cmdlet should use standard parameter names so that the user can quickly determine what a particular parameter means.</span></span> <span data-ttu-id="11ce0-129">より具体的な名前が必要な場合は、標準パラメーター名を使用し、別名としてより具体的な名前を指定します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-129">If a more specific name is required, use a standard parameter name, and then specify a more specific name as an alias.</span></span> <span data-ttu-id="11ce0-130">たとえば、 `Get-Service` コマンドレットには、汎用名 ( `Name` ) とより具体的な別名 () を持つパラメーターがあり `ServiceName` ます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-130">For example, the `Get-Service` cmdlet has a parameter that has a generic name (`Name`) and a more specific alias (`ServiceName`).</span></span> <span data-ttu-id="11ce0-131">両方の用語を使用してパラメーターを指定できます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-131">Both terms can be used to specify the parameter.</span></span>

<span data-ttu-id="11ce0-132">パラメーター名とそのデータ型の詳細については、「 [コマンドレットパラメーターの名前と機能のガイドライン](./standard-cmdlet-parameter-names-and-types.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="11ce0-132">For more information about parameter names and their data types, see [Cmdlet Parameter Name and Functionality Guidelines](./standard-cmdlet-parameter-names-and-types.md).</span></span>

#### <a name="use-singular-parameter-names"></a><span data-ttu-id="11ce0-133">単数形のパラメーター名を使用する</span><span class="sxs-lookup"><span data-stu-id="11ce0-133">Use Singular Parameter Names</span></span>

<span data-ttu-id="11ce0-134">値が1つの要素であるパラメーターに複数形の名前を使用することは避けてください。</span><span class="sxs-lookup"><span data-stu-id="11ce0-134">Avoid using plural names for parameters whose value is a single element.</span></span> <span data-ttu-id="11ce0-135">これには、配列またはリストを受け取るパラメーターが含まれます。これは、ユーザーが1つの要素のみを含む配列またはリストを指定する可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="11ce0-135">This includes parameters that take arrays or lists because the user might supply an array or list with only one element.</span></span>

<span data-ttu-id="11ce0-136">複数形のパラメーター名は、パラメーターの値が常に複数要素の値である場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="11ce0-136">Plural parameter names should be used only in those cases where the value of the parameter is always a multiple-element value.</span></span> <span data-ttu-id="11ce0-137">このような場合、コマンドレットは複数の要素が指定されていることを確認する必要があり、複数の要素が指定されていない場合は、コマンドレットによってユーザーに警告が表示されます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-137">In these cases, the cmdlet should verify that multiple elements are supplied, and the cmdlet should display a warning to the user if multiple elements are not supplied.</span></span>

#### <a name="use-pascal-case-for-parameter-names"></a><span data-ttu-id="11ce0-138">パラメーター名に Pascal ケースを使用する</span><span class="sxs-lookup"><span data-stu-id="11ce0-138">Use Pascal Case for Parameter Names</span></span>

<span data-ttu-id="11ce0-139">パラメーター名には Pascal 形式を使用します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-139">Use Pascal case for parameter names.</span></span> <span data-ttu-id="11ce0-140">つまり、名前の最初の文字を含め、パラメーター名に含まれる各単語の最初の文字を大文字にします。</span><span class="sxs-lookup"><span data-stu-id="11ce0-140">In other words, capitalize the first letter of each word in the parameter name, including the first letter of the name.</span></span> <span data-ttu-id="11ce0-141">たとえば、パラメーター名では、 `ErrorAction` 大文字小文字が正しく使用されます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-141">For example, the parameter name `ErrorAction` uses the correct capitalization.</span></span> <span data-ttu-id="11ce0-142">次のパラメーター名では大文字と小文字が正しく使用されません。</span><span class="sxs-lookup"><span data-stu-id="11ce0-142">The following parameter names use incorrect capitalization:</span></span>

- `errorAction`
- `erroraction`

#### <a name="parameters-that-take-a-list-of-options"></a><span data-ttu-id="11ce0-143">オプションの一覧を受け取るパラメーター</span><span class="sxs-lookup"><span data-stu-id="11ce0-143">Parameters That Take a List of Options</span></span>

<span data-ttu-id="11ce0-144">一連のオプションから値を選択できるパラメーターを作成するには、次の2つの方法があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-144">There are two ways to create a parameter whose value can be selected from a set of options.</span></span>

- <span data-ttu-id="11ce0-145">有効な値を指定する列挙型を定義します (または、既存の列挙型を使用します)。</span><span class="sxs-lookup"><span data-stu-id="11ce0-145">Define an enumeration type (or use an existing enumeration type) that specifies the valid values.</span></span>
  <span data-ttu-id="11ce0-146">次に、列挙型を使用して、その型のパラメーターを作成します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-146">Then, use the enumeration type to create a parameter of that type.</span></span>

- <span data-ttu-id="11ce0-147">パラメーター宣言に **Validateset** 属性を追加します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-147">Add the **ValidateSet** attribute to the parameter declaration.</span></span> <span data-ttu-id="11ce0-148">この属性の詳細については、「 [Validateset 属性の宣言](./validateset-attribute-declaration.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="11ce0-148">For more information about this attribute, see [ValidateSet Attribute Declaration](./validateset-attribute-declaration.md).</span></span>

#### <a name="use-standard-types-for-parameters"></a><span data-ttu-id="11ce0-149">パラメーターに標準の型を使用する</span><span class="sxs-lookup"><span data-stu-id="11ce0-149">Use Standard Types for Parameters</span></span>

<span data-ttu-id="11ce0-150">他のコマンドレットとの一貫性を確保するには、可能な限りパラメーターに標準の型を使用します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-150">To ensure consistency with other cmdlets, use standard types for parameters where ever possible.</span></span> <span data-ttu-id="11ce0-151">異なるパラメーターに使用する型の詳細については、「 [標準のコマンドレットパラメーター名と型](./standard-cmdlet-parameter-names-and-types.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="11ce0-151">For more information about the types that should be used for different parameter, see [Standard Cmdlet Parameter Names and Types](./standard-cmdlet-parameter-names-and-types.md).</span></span> <span data-ttu-id="11ce0-152">このトピックでは、"アクティビティパラメーター" など、標準パラメーターのグループの名前と .NET Framework 型について説明しているいくつかのトピックへのリンクを示します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-152">This topic provides links to several topics that describe the names and .NET Framework types for groups of standard parameters, such as the "activity parameters".</span></span>

#### <a name="use-strongly-typed-net-framework-types"></a><span data-ttu-id="11ce0-153">Strongly-Typed .NET Framework の種類を使用する</span><span class="sxs-lookup"><span data-stu-id="11ce0-153">Use Strongly-Typed .NET Framework Types</span></span>

<span data-ttu-id="11ce0-154">パラメーターの検証を強化するには、パラメーターを .NET Framework 型として定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-154">Parameters should be defined as .NET Framework types to provide better parameter validation.</span></span> <span data-ttu-id="11ce0-155">たとえば、値のセットから1つの値に制限されているパラメーターは、列挙型として定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-155">For example, parameters that are restricted to one value from a set of values should be defined as an enumeration type.</span></span> <span data-ttu-id="11ce0-156">Uniform Resource Identifier (URI) 値をサポートするには、パラメーターを system.string [型と](/dotnet/api/System.Uri) して定義します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-156">To support a Uniform Resource Identifier (URI) value, define the parameter as a [System.Uri](/dotnet/api/System.Uri) type.</span></span> <span data-ttu-id="11ce0-157">自由形式のテキストプロパティ以外のすべてに対して、基本的な文字列パラメーターを使用しないようにします。</span><span class="sxs-lookup"><span data-stu-id="11ce0-157">Avoid basic string parameters for all but free-form text properties.</span></span>

#### <a name="use-consistent-parameter-types"></a><span data-ttu-id="11ce0-158">一貫したパラメーターの型を使用する</span><span class="sxs-lookup"><span data-stu-id="11ce0-158">Use Consistent Parameter Types</span></span>

<span data-ttu-id="11ce0-159">複数のコマンドレットで同じパラメーターを使用する場合は、常に同じパラメーターの型を使用します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-159">When the same parameter is used by multiple cmdlets, always use the same parameter type.</span></span> <span data-ttu-id="11ce0-160">たとえば、 `Process` パラメーターが1つのコマンドレットの [Int16](/dotnet/api/System.Int16) 型である場合、 `Process` 別のコマンドレットのパラメーターを [Uint16](/dotnet/api/System.UInt16) 型にしないでください。</span><span class="sxs-lookup"><span data-stu-id="11ce0-160">For example, if the `Process` parameter is an [System.Int16](/dotnet/api/System.Int16) type for one cmdlet, do not make the `Process` parameter for another cmdlet a [System.Uint16](/dotnet/api/System.UInt16) type.</span></span>

#### <a name="parameters-that-take-true-and-false"></a><span data-ttu-id="11ce0-161">True および False を受け取るパラメーター</span><span class="sxs-lookup"><span data-stu-id="11ce0-161">Parameters That Take True and False</span></span>

<span data-ttu-id="11ce0-162">パラメーターがとのみを受け取る場合は `true` `false` 、パラメーターを型 system.string として定義 [します](/dotnet/api/System.Management.Automation.SwitchParameter)。</span><span class="sxs-lookup"><span data-stu-id="11ce0-162">If your parameter takes only `true` and `false`, define the parameter as type [System.Management.Automation.SwitchParameter](/dotnet/api/System.Management.Automation.SwitchParameter).</span></span>
<span data-ttu-id="11ce0-163">スイッチパラメーターは、コマンドで指定されている場合と同じように扱われ `true` ます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-163">A switch parameter is treated as `true` when it is specified in a command.</span></span> <span data-ttu-id="11ce0-164">パラメーターがコマンドに含まれていない場合、Windows PowerShell はパラメーターの値をと見なし `false` ます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-164">If the parameter is not included in a command, Windows PowerShell considers the value of the parameter to be `false`.</span></span> <span data-ttu-id="11ce0-165">ブール型パラメーターを定義しないでください。</span><span class="sxs-lookup"><span data-stu-id="11ce0-165">Do not define Boolean parameters.</span></span>

<span data-ttu-id="11ce0-166">パラメーターが3つの値 ($true、$false、および "未指定") を区別する必要がある場合は、Null 値を許容する型のパラメーターを定義し \<bool> ます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-166">If your parameter needs to differentiate between 3 values: $true, $false and "unspecified", then define a parameter of type Nullable\<bool>.</span></span> <span data-ttu-id="11ce0-167">3番目の "未指定" 値の必要性は、通常、コマンドレットでオブジェクトのブール型プロパティを変更できる場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-167">The need for a 3rd, "unspecified" value typically occurs when the cmdlet can modify a Boolean property of an object.</span></span> <span data-ttu-id="11ce0-168">この場合、"未指定" は、プロパティの現在の値を変更しないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-168">In this case "unspecified" means to not change the current value of the property.</span></span>

#### <a name="support-arrays-for-parameters"></a><span data-ttu-id="11ce0-169">パラメーターのサポート配列</span><span class="sxs-lookup"><span data-stu-id="11ce0-169">Support Arrays for Parameters</span></span>

<span data-ttu-id="11ce0-170">多くの場合、ユーザーは複数の引数に対して同じ操作を実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-170">Frequently, users must perform the same operation against multiple arguments.</span></span> <span data-ttu-id="11ce0-171">これらのユーザーについては、コマンドレットでパラメーター入力として配列を受け取ることで、ユーザーが Windows PowerShell 変数として引数をパラメーターに渡すことができるようになります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-171">For these users, a cmdlet should accept an array as parameter input so that a user can pass the arguments into the parameter as a Windows PowerShell variable.</span></span> <span data-ttu-id="11ce0-172">たとえば、 [Get Process](/powershell/module/Microsoft.PowerShell.Management/Get-Process) コマンドレットは、取得するプロセスの名前を識別する文字列に配列を使用します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-172">For example, the [Get-Process](/powershell/module/Microsoft.PowerShell.Management/Get-Process) cmdlet uses an array for the strings that identify the names of the processes to retrieve.</span></span>

#### <a name="support-the-passthru-parameter"></a><span data-ttu-id="11ce0-173">PassThru パラメーターのサポート</span><span class="sxs-lookup"><span data-stu-id="11ce0-173">Support the PassThru Parameter</span></span>

<span data-ttu-id="11ce0-174">既定では、 [Stop Process](/powershell/module/Microsoft.PowerShell.Management/Stop-Process) コマンドレットなど、システムを変更する多くのコマンドレットは、オブジェクトの "シンク" として機能し、結果を返しません。</span><span class="sxs-lookup"><span data-stu-id="11ce0-174">By default, many cmdlets that modify the system, such as the [Stop-Process](/powershell/module/Microsoft.PowerShell.Management/Stop-Process) cmdlet, act as "sinks" for objects and do not return a result.</span></span> <span data-ttu-id="11ce0-175">これらのコマンドレットは、パラメーターを実装して、 `PassThru` コマンドレットが強制的にオブジェクトを返すようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-175">These cmdlet should implement the `PassThru` parameter to force the cmdlet to return an object.</span></span> <span data-ttu-id="11ce0-176">パラメーターを指定した場合 `PassThru` 、コマンドレットは [WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) メソッドの呼び出しを使用してオブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-176">When the `PassThru` parameter is specified, the cmdlet returns an object by using a call to the [System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) method.</span></span> <span data-ttu-id="11ce0-177">たとえば、次のコマンドを実行すると、Calc プロセスが停止され、結果のプロセスがパイプラインに渡されます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-177">For example, the following command stops the Calc process and passes the resultant process to the pipeline.</span></span>

```powershell
Stop-Process calc -passthru
```

<span data-ttu-id="11ce0-178">ほとんどの場合、Add、Set、および New コマンドレットではパラメーターをサポートする必要があり `PassThru` ます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-178">In most cases, Add, Set, and New cmdlets should support a `PassThru` parameter.</span></span>

#### <a name="support-parameter-sets"></a><span data-ttu-id="11ce0-179">パラメーターセットのサポート</span><span class="sxs-lookup"><span data-stu-id="11ce0-179">Support Parameter Sets</span></span>

<span data-ttu-id="11ce0-180">コマンドレットは、単一の目的を実現することを目的としています。</span><span class="sxs-lookup"><span data-stu-id="11ce0-180">A cmdlet is intended to accomplish a single purpose.</span></span> <span data-ttu-id="11ce0-181">ただし、多くの場合、操作または操作ターゲットを記述する方法は複数あります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-181">However, there is frequently more than one way to describe the operation or the operation target.</span></span> <span data-ttu-id="11ce0-182">たとえば、プロセスは名前、識別子、またはプロセスオブジェクトによって識別される場合があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-182">For example, a process might be identified by its name, by its identifier, or by a process object.</span></span> <span data-ttu-id="11ce0-183">コマンドレットは、ターゲットのすべての適切な表現をサポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-183">The cmdlet should support all the reasonable representations of its targets.</span></span> <span data-ttu-id="11ce0-184">通常、コマンドレットは、一緒に動作するパラメーターのセット (パラメーターセットと呼ばれます) を指定することによって、この要件を満たします。</span><span class="sxs-lookup"><span data-stu-id="11ce0-184">Normally, the cmdlet satisfies this requirement by specifying sets of parameters (referred to as parameter sets) that operate together.</span></span> <span data-ttu-id="11ce0-185">1つのパラメーターは、任意の数のパラメーターセットに属することができます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-185">A single parameter can belong to any number of parameter sets.</span></span> <span data-ttu-id="11ce0-186">パラメーターセットの詳細については、「 [コマンドレットパラメーターセット](./cmdlet-parameter-sets.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="11ce0-186">For more information about parameter sets, see [Cmdlet Parameter Sets](./cmdlet-parameter-sets.md).</span></span>

<span data-ttu-id="11ce0-187">パラメーターセットを指定する場合は、[ValueFromPipeline に設定] でパラメーターを1つだけ設定します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-187">When you specify parameter sets, set only one parameter in the set to ValueFromPipeline.</span></span> <span data-ttu-id="11ce0-188">**パラメーター** 属性を宣言する方法の詳細については、「 [parameterattribute 宣言](./parameter-attribute-declaration.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="11ce0-188">For more information about how to declare the **Parameter** attribute, see [ParameterAttribute Declaration](./parameter-attribute-declaration.md).</span></span>

<span data-ttu-id="11ce0-189">パラメーターセットを使用する場合、既定のパラメーターセットは **コマンドレット** 属性によって定義されます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-189">When parameter sets are used, the default parameter set is defined by the **Cmdlet** attribute.</span></span> <span data-ttu-id="11ce0-190">既定のパラメーターセットには、対話型の Windows PowerShell セッションで使用される可能性が最も高いパラメーターを含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-190">The default parameter set should include the parameters most likely to be used in an interactive Windows PowerShell session.</span></span> <span data-ttu-id="11ce0-191">コマンドレット属性を宣言する方法の詳細については、「**コマンドレット**[属性の宣言](./cmdlet-attribute-declaration.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="11ce0-191">For more information about how to declare the **Cmdlet** attribute, see [CmdletAttribute Declaration](./cmdlet-attribute-declaration.md).</span></span>

### <a name="provide-feedback-to-the-user-sd04"></a><span data-ttu-id="11ce0-192">ユーザーにフィードバックを提供する (SD04)</span><span class="sxs-lookup"><span data-stu-id="11ce0-192">Provide Feedback to the User (SD04)</span></span>

<span data-ttu-id="11ce0-193">このセクションのガイドラインを使用して、ユーザーにフィードバックを提供します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-193">Use the guidelines in this section to provide feedback to the user.</span></span> <span data-ttu-id="11ce0-194">このフィードバックによって、ユーザーはシステムで発生していることを認識し、管理上の決定をより適切に行うことができます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-194">This feedback allows the user to be aware of what is occurring in the system and to make better administrative decisions.</span></span>

<span data-ttu-id="11ce0-195">ユーザーは、Windows PowerShell ランタイムを使用して、ユーザー設定変数を設定することによって、メソッドの各呼び出しからの出力の処理方法を指定でき `Write` ます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-195">The Windows PowerShell runtime allows a user to specify how to handle output from each call to the `Write` method by setting a preference variable.</span></span> <span data-ttu-id="11ce0-196">ユーザーは、システムが情報を表示するかどうかを決定する変数や、追加のアクションを実行する前にシステムがユーザーを照会する必要があるかどうかを判断する変数など、いくつかのユーザー設定変数を設定できます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-196">The user can set several preference variables, including a variable that determines whether the system should display information and a variable that determines whether the system should query the user before taking further action.</span></span>

#### <a name="support-the-writewarning-writeverbose-and-writedebug-methods"></a><span data-ttu-id="11ce0-197">WriteWarning、Writewarning、および Writewarning メソッドのサポート</span><span class="sxs-lookup"><span data-stu-id="11ce0-197">Support the WriteWarning, WriteVerbose, and WriteDebug Methods</span></span>

<span data-ttu-id="11ce0-198">コマンドレットで、予期しない結果になる可能性のある操作を実行しようとしているときに、コマンドレットでは、 [このメソッドを](/dotnet/api/System.Management.Automation.Cmdlet.WriteWarning) 呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-198">A cmdlet should call the [System.Management.Automation.Cmdlet.WriteWarning](/dotnet/api/System.Management.Automation.Cmdlet.WriteWarning) method when the cmdlet is about to perform an operation that might have an unintended result.</span></span> <span data-ttu-id="11ce0-199">たとえば、コマンドレットで読み取り専用ファイルを上書きする場合は、コマンドレットでこのメソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-199">For example, a cmdlet should call this method if the cmdlet is about to overwrite a read-only file.</span></span>

<span data-ttu-id="11ce0-200">コマンドレットでは、コマンドレットの実行内容についての詳細が必要な場合 [に、system.servicemodel メソッドを](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) 呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-200">A cmdlet should call the [System.Management.Automation.Cmdlet.WriteVerbose](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) method when the user requires some detail about what the cmdlet is doing.</span></span> <span data-ttu-id="11ce0-201">たとえば、コマンドレットの作成者が、コマンドレットの動作に関する詳細情報を必要とするシナリオがあると感じる場合は、コマンドレットでこの情報を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-201">For example, a cmdlet should call this information if the cmdlet author feels that there are scenarios that might require more information about what the cmdlet is doing.</span></span>

<span data-ttu-id="11ce0-202">開発者または製品サポートエンジニアが、コマンドレットの操作を破損していることを理解する必要がある場合は、コマンドレットで [system.servicemodel メソッドを](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) 呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-202">The cmdlet should call the [System.Management.Automation.Cmdlet.WriteDebug](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) method when a developer or product support engineer must understand what has corrupted the cmdlet operation.</span></span> <span data-ttu-id="11ce0-203">このコマンドレットでは、両方の情報セットを指定するため、このメソッドを呼び出すのと同じコードで、 [このメソッドを](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) 呼び出す必要はありません。 [このメソッドは](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) 、パラメーターによって `Debug` 両方の情報が提示されるためです。</span><span class="sxs-lookup"><span data-stu-id="11ce0-203">It is not necessary for the cmdlet to call the [System.Management.Automation.Cmdlet.WriteDebug](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) method in the same code that calls the [System.Management.Automation.Cmdlet.WriteVerbose](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) method because the `Debug` parameter presents both sets of information.</span></span>

#### <a name="support-writeprogress-for-operations-that-take-a-long-time"></a><span data-ttu-id="11ce0-204">長い時間がかかる操作の WriteProgress をサポートする</span><span class="sxs-lookup"><span data-stu-id="11ce0-204">Support WriteProgress for Operations that take a Long Time</span></span>

<span data-ttu-id="11ce0-205">完了までに時間がかかり、バックグラウンドで実行できないコマンドレット操作は、 [システム](/dotnet/api/System.Management.Automation.Cmdlet.WriteProgress) の定期的な呼び出しによる進行状況の報告をサポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-205">Cmdlet operations that take a long time to complete and that cannot run in the background should support progress reporting through periodic calls to the [System.Management.Automation.Cmdlet.WriteProgress](/dotnet/api/System.Management.Automation.Cmdlet.WriteProgress) method.</span></span>

#### <a name="use-the-host-interfaces"></a><span data-ttu-id="11ce0-206">ホストインターフェイスを使用する</span><span class="sxs-lookup"><span data-stu-id="11ce0-206">Use the Host Interfaces</span></span>

<span data-ttu-id="11ce0-207">場合によっては、コマンドレットが、の代わりにユーザーと直接通信する必要があります。そのためには、の代わりに、 [System.](/dotnet/api/System.Management.Automation.Cmdlet) .. cmdlet クラスでサポートされているさまざまな Write メソッドまたは if メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-207">Occasionally, a cmdlet must communicate directly with the user instead of by using the various Write or Should methods supported by the [System.Management.Automation.Cmdlet](/dotnet/api/System.Management.Automation.Cmdlet) class.</span></span> <span data-ttu-id="11ce0-208">この場合、コマンドレットは、 [PSCmdlet](/dotnet/api/System.Management.Automation.PSCmdlet) クラスから派生し、 [PSCmdlet \*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) プロパティを使用する必要があります。この例では、</span><span class="sxs-lookup"><span data-stu-id="11ce0-208">In this case, the cmdlet should derive from the [System.Management.Automation.PSCmdlet](/dotnet/api/System.Management.Automation.PSCmdlet) class and use the [System.Management.Automation.PSCmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) property.</span></span> <span data-ttu-id="11ce0-209">このプロパティは、PromptForChoice、Prompt、および WriteLine/ReadLine の種類など、さまざまなレベルの通信の種類をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="11ce0-209">This property supports different levels of communication type, including the PromptForChoice, Prompt, and WriteLine/ReadLine types.</span></span> <span data-ttu-id="11ce0-210">最も具体的なレベルでは、個々のキーの読み取りと書き込みを行ったり、バッファーを処理したりする方法も提供されます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-210">At the most specific level, it also provides ways to read and write individual keys and to deal with buffers.</span></span>

<span data-ttu-id="11ce0-211">コマンドレットがグラフィカルユーザーインターフェイス (GUI) を生成するように設計されていない限り、 [PSCmdlet \*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) プロパティを使用してホストをバイパスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="11ce0-211">Unless a cmdlet is specifically designed to generate a graphical user interface (GUI), it should not bypass the host by using the [System.Management.Automation.PSCmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) property.</span></span> <span data-ttu-id="11ce0-212">GUI を生成するように設計されたコマンドレットの例としては、 [Out GridView](/powershell/module/Microsoft.PowerShell.Utility/Out-GridView) コマンドレットがあります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-212">An example of a cmdlet that is designed to generate a GUI is the [Out-GridView](/powershell/module/Microsoft.PowerShell.Utility/Out-GridView) cmdlet.</span></span>

> [!NOTE]
> <span data-ttu-id="11ce0-213">コマンドレットで [は、System.string API を使用](/dotnet/api/System.Console) しないでください。</span><span class="sxs-lookup"><span data-stu-id="11ce0-213">Cmdlets should not use the [System.Console](/dotnet/api/System.Console) API.</span></span>

### <a name="create-a-cmdlet-help-file-sd05"></a><span data-ttu-id="11ce0-214">コマンドレットのヘルプファイルを作成する (SD05)</span><span class="sxs-lookup"><span data-stu-id="11ce0-214">Create a Cmdlet Help File (SD05)</span></span>

<span data-ttu-id="11ce0-215">各コマンドレットアセンブリについて、コマンドレットに関する情報を含む Help.xml ファイルを作成します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-215">For each cmdlet assembly, create a Help.xml file that contains information about the cmdlet.</span></span> <span data-ttu-id="11ce0-216">この情報には、コマンドレットの説明、コマンドレットのパラメーターの説明、コマンドレットの使用例などが含まれます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-216">This information includes a description of the cmdlet, descriptions of the cmdlet's parameters, examples of the cmdlet's use, and more.</span></span>

## <a name="code-guidelines"></a><span data-ttu-id="11ce0-217">コードのガイドライン</span><span class="sxs-lookup"><span data-stu-id="11ce0-217">Code Guidelines</span></span>

<span data-ttu-id="11ce0-218">コマンドレットとその他のコマンドレットを使用して一貫したユーザーエクスペリエンスを確保するには、次のガイドラインに従う必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-218">The following guidelines should be followed when coding cmdlets to ensure a consistent user experience between using your cmdlets and other cmdlets.</span></span> <span data-ttu-id="11ce0-219">状況に当てはまるコードガイドラインが見つかった場合は、デザインガイドラインで同様のガイドラインを確認してください。</span><span class="sxs-lookup"><span data-stu-id="11ce0-219">When you find a Code guideline that applies to your situation, be sure to look at the Design guidelines for similar guidelines.</span></span>

### <a name="coding-parameters-sc01"></a><span data-ttu-id="11ce0-220">パラメーターのコーディング (SC01)</span><span class="sxs-lookup"><span data-stu-id="11ce0-220">Coding Parameters (SC01)</span></span>

<span data-ttu-id="11ce0-221">**パラメーター属性で** 修飾されたコマンドレットクラスのパブリックプロパティを宣言して、パラメーターを定義します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-221">Define a parameter by declaring a public property of the cmdlet class that is decorated with the **Parameter** attribute.</span></span> <span data-ttu-id="11ce0-222">パラメーターは、コマンドレットの派生 .NET Framework クラスの静的メンバーである必要はありません。</span><span class="sxs-lookup"><span data-stu-id="11ce0-222">Parameters do not have to be static members of the derived .NET Framework class for the cmdlet.</span></span> <span data-ttu-id="11ce0-223">**パラメーター** 属性を宣言する方法の詳細については、「[パラメーター属性の宣言](./parameter-attribute-declaration.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="11ce0-223">For more information about how to declare the **Parameter** attribute, see [Parameter Attribute Declaration](./parameter-attribute-declaration.md).</span></span>

#### <a name="support-windows-powershell-paths"></a><span data-ttu-id="11ce0-224">Windows PowerShell パスのサポート</span><span class="sxs-lookup"><span data-stu-id="11ce0-224">Support Windows PowerShell Paths</span></span>

<span data-ttu-id="11ce0-225">Windows PowerShell のパスは、名前空間へのアクセスを標準化するためのメカニズムです。</span><span class="sxs-lookup"><span data-stu-id="11ce0-225">The Windows PowerShell path is the mechanism for normalizing access to namespaces.</span></span> <span data-ttu-id="11ce0-226">コマンドレットのパラメーターに Windows PowerShell のパスを割り当てると、ユーザーは、特定のパスへのショートカットとして機能するカスタムの "ドライブ" を定義できます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-226">When you assign a Windows PowerShell path to a parameter in the cmdlet, the user can define a custom "drive" that acts as a shortcut to a specific path.</span></span> <span data-ttu-id="11ce0-227">ユーザーがこのようなドライブを指定すると、レジストリ内のデータなどの格納されたデータを一貫した方法で使用できます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-227">When a user designates such a drive, stored data, such as data in the Registry, can be used in a consistent way.</span></span>

<span data-ttu-id="11ce0-228">コマンドレットで、ユーザーがファイルまたはデータソースを指定できるようにするには、 [system.string](/dotnet/api/System.String)型のパラメーターを定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-228">If your cmdlet allows the user to specify a file or a data source, it should define a parameter of type [System.String](/dotnet/api/System.String).</span></span> <span data-ttu-id="11ce0-229">複数のドライブがサポートされている場合、その型は配列である必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-229">If more than one drive is supported, the type should be an array.</span></span> <span data-ttu-id="11ce0-230">パラメーターの名前は、のエイリアスを持つである必要があり `Path` `PSPath` ます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-230">The name of the parameter should be `Path`, with an alias of `PSPath`.</span></span>
<span data-ttu-id="11ce0-231">また、 `Path` パラメーターはワイルドカード文字をサポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-231">Additionally, the `Path` parameter should support wildcard characters.</span></span> <span data-ttu-id="11ce0-232">ワイルドカード文字のサポートが不要な場合は、 `LiteralPath` パラメーターを定義します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-232">If support for wildcard characters is not required, define a `LiteralPath` parameter.</span></span>

<span data-ttu-id="11ce0-233">コマンドレットで読み取りまたは書き込みを行うデータをファイルにする必要がある場合、コマンドレットは Windows PowerShell パス入力を受け入れる必要があります。また、コマンドレットは、 [Sessionstate](/dotnet/api/System.Management.Automation.SessionState.Path) プロパティを使用して、windows powershell パスをファイルシステムが認識するパスに変換します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-233">If the data that the cmdlet reads or writes has to be a file, the cmdlet should accept Windows PowerShell path input, and the cmdlet should use the [System.Management.Automation.Sessionstate.Path](/dotnet/api/System.Management.Automation.SessionState.Path) property to translate the Windows PowerShell paths into paths that the file system recognizes.</span></span> <span data-ttu-id="11ce0-234">具体的なメカニズムには、次のメソッドがあります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-234">The specific mechanisms include the following methods:</span></span>

- [<span data-ttu-id="11ce0-235">PSCmdlet. GetResolvedProviderPathFromPSPath (システムの管理)</span><span class="sxs-lookup"><span data-stu-id="11ce0-235">System.Management.Automation.PSCmdlet.GetResolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PSCmdlet.GetResolvedProviderPathFromPSPath)
- [<span data-ttu-id="11ce0-236">PSCmdlet. GetUnresolvedProviderPathFromPSPath (システムの管理)</span><span class="sxs-lookup"><span data-stu-id="11ce0-236">System.Management.Automation.PSCmdlet.GetUnresolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PSCmdlet.GetUnresolvedProviderPathFromPSPath)
- [<span data-ttu-id="11ce0-237">GetResolvedProviderPathFromPSPath (システムの管理)</span><span class="sxs-lookup"><span data-stu-id="11ce0-237">System.Management.Automation.PathIntrinsics.GetResolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PathIntrinsics.GetResolvedProviderPathFromPSPath)
- [<span data-ttu-id="11ce0-238">GetUnresolvedProviderPathFromPSPath (システムの管理)</span><span class="sxs-lookup"><span data-stu-id="11ce0-238">System.Management.Automation.PathIntrinsics.GetUnresolvedProviderPathFromPSPath</span></span>](/dotnet/api/System.Management.Automation.PathIntrinsics.GetUnresolvedProviderPathFromPSPath)

<span data-ttu-id="11ce0-239">コマンドレットによって読み取りまたは書き込みが行うデータがファイルではなく文字列のセットである場合、コマンドレットではプロバイダーのコンテンツ情報 ( `Content` メンバー) を使用して読み取りと書き込みを行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-239">If the data that the cmdlet reads or writes is only a set of strings instead of a file, the cmdlet should use the provider content information (`Content` member) to read and write.</span></span> <span data-ttu-id="11ce0-240">この情報は、システムの [管理](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.InvokeProvider) ............. プロパティから取得されます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-240">This information is obtained from the [System.Management.Automation.Provider.CmdletProvider.InvokeProvider](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.InvokeProvider) property.</span></span> <span data-ttu-id="11ce0-241">これらのメカニズムにより、データの読み取りと書き込みに他のデータストアを参加させることができます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-241">These mechanisms allow other data stores to participate in the reading and writing of data.</span></span>

#### <a name="support-wildcard-characters"></a><span data-ttu-id="11ce0-242">ワイルドカード文字のサポート</span><span class="sxs-lookup"><span data-stu-id="11ce0-242">Support Wildcard Characters</span></span>

<span data-ttu-id="11ce0-243">可能であれば、コマンドレットでワイルドカード文字をサポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-243">A cmdlet should support wildcard characters if possible.</span></span> <span data-ttu-id="11ce0-244">ワイルドカード文字のサポートは、コマンドレットの多くの場所で発生します (特に、パラメーターがオブジェクトのセットから1つのオブジェクトを識別するために文字列を受け取る場合)。</span><span class="sxs-lookup"><span data-stu-id="11ce0-244">Support for wildcard characters occurs in many places in a cmdlet (especially when a parameter takes a string to identify one object from a set of objects).</span></span> <span data-ttu-id="11ce0-245">たとえば、 [Stopproc チュートリアル](./stopproc-tutorial.md)のサンプルの **Stop proc** コマンドレットは、 `Name` プロセス名を表す文字列を処理するパラメーターを定義します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-245">For example, the sample **Stop-Proc** cmdlet from the [StopProc Tutorial](./stopproc-tutorial.md) defines a `Name` parameter to handle strings that represent process names.</span></span> <span data-ttu-id="11ce0-246">このパラメーターは、ユーザーが停止するプロセスを簡単に指定できるように、ワイルドカード文字をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="11ce0-246">This parameter supports wildcard characters so that the user can easily specify the processes to stop.</span></span>

<span data-ttu-id="11ce0-247">ワイルドカード文字のサポートが使用可能な場合、コマンドレットの操作では通常、配列が生成されます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-247">When support for wildcard characters is available, a cmdlet operation usually produces an array.</span></span>
<span data-ttu-id="11ce0-248">場合によっては、ユーザーが一度に1つの項目のみを使用する可能性があるため、配列をサポートすることは意味がありません。</span><span class="sxs-lookup"><span data-stu-id="11ce0-248">Occasionally, it does not make sense to support an array because the user might use only a single item at a time.</span></span> <span data-ttu-id="11ce0-249">たとえば、 [Set location](/powershell/module/Microsoft.PowerShell.Management/Set-Location) コマンドレットは、ユーザーが1つの場所のみを設定するため、配列をサポートする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="11ce0-249">For example, the [Set-Location](/powershell/module/Microsoft.PowerShell.Management/Set-Location) cmdlet does not need to support an array because the user is setting only a single location.</span></span> <span data-ttu-id="11ce0-250">このインスタンスでは、コマンドレットはワイルドカード文字を引き続きサポートしますが、1つの場所を強制的に解決します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-250">In this instance, the cmdlet still supports wildcard characters, but it forces resolution to a single location.</span></span>

<span data-ttu-id="11ce0-251">ワイルドカード文字パターンの詳細については、「 [コマンドレットパラメーターでのワイルドカード文字のサポート](./supporting-wildcard-characters-in-cmdlet-parameters.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="11ce0-251">For more information about wildcard-character patterns, see [Supporting Wildcard Characters in Cmdlet Parameters](./supporting-wildcard-characters-in-cmdlet-parameters.md).</span></span>

#### <a name="defining-objects"></a><span data-ttu-id="11ce0-252">オブジェクトの定義</span><span class="sxs-lookup"><span data-stu-id="11ce0-252">Defining Objects</span></span>

<span data-ttu-id="11ce0-253">ここでは、コマンドレットのオブジェクトを定義し、既存のオブジェクトを拡張するためのガイドラインについて説明します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-253">This section contains guidelines for defining objects for cmdlets and for extending existing objects.</span></span>

##### <a name="define-standard-members"></a><span data-ttu-id="11ce0-254">標準メンバーの定義</span><span class="sxs-lookup"><span data-stu-id="11ce0-254">Define Standard Members</span></span>

<span data-ttu-id="11ce0-255">カスタム Types.ps1xml ファイル内のオブジェクトの種類を拡張する標準メンバーを定義します (Windows PowerShell Types.ps1xml ファイルをテンプレートとして使用します)。</span><span class="sxs-lookup"><span data-stu-id="11ce0-255">Define standard members to extend an object type in a custom Types.ps1xml file (use the Windows PowerShell Types.ps1xml file as a template).</span></span> <span data-ttu-id="11ce0-256">標準メンバーは、PSStandardMembers という名前のノードによって定義されます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-256">Standard members are defined by a node with the name PSStandardMembers.</span></span> <span data-ttu-id="11ce0-257">これらの定義により、他のコマンドレットと Windows PowerShell ランタイムは、一貫した方法でオブジェクトを操作できます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-257">These definitions allow other cmdlets and the Windows PowerShell runtime to work with your object in a consistent way.</span></span>

##### <a name="define-objectmembers-to-be-used-as-parameters"></a><span data-ttu-id="11ce0-258">パラメーターとして使用する ObjectMembers を定義する</span><span class="sxs-lookup"><span data-stu-id="11ce0-258">Define ObjectMembers to Be Used as Parameters</span></span>

<span data-ttu-id="11ce0-259">コマンドレットのオブジェクトをデザインする場合は、そのオブジェクトが使用されるコマンドレットのパラメーターに、そのメンバーが直接マップされていることを確認してください。</span><span class="sxs-lookup"><span data-stu-id="11ce0-259">If you are designing an object for a cmdlet, ensure that its members map directly to the parameters of the cmdlets that will use it.</span></span> <span data-ttu-id="11ce0-260">このマッピングにより、オブジェクトをパイプラインに簡単に送信し、1つのコマンドレットから別のコマンドレットに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-260">This mapping allows the object to be easily sent to the pipeline and to be passed from one cmdlet to another.</span></span>

<span data-ttu-id="11ce0-261">コマンドレットによって返される既存の .NET Framework オブジェクトには、多くの場合、スクリプト開発者やユーザーが必要とする重要なメンバーや便利なメンバーが不足しています。</span><span class="sxs-lookup"><span data-stu-id="11ce0-261">Preexisting .NET Framework objects that are returned by cmdlets are frequently missing some important or convenient members that are needed by the script developer or user.</span></span> <span data-ttu-id="11ce0-262">これらの不足しているメンバーは、表示する場合や、正しいメンバー名を作成する場合に特に重要であり、オブジェクトをパイプラインに正しく渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-262">These missing members can be particularly important for display and for creating the correct member names so that the object can be correctly passed to the pipeline.</span></span> <span data-ttu-id="11ce0-263">これらの必要なメンバーを文書化するためのカスタム Types.ps1xml ファイルを作成します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-263">Create a custom Types.ps1xml file to document these required members.</span></span> <span data-ttu-id="11ce0-264">このファイルを作成するときは、次の名前付け規則に従うことをお勧めします。 *<Your_Product_Name>*.Types.ps1xml です。</span><span class="sxs-lookup"><span data-stu-id="11ce0-264">When you create this file, we recommend the following naming convention: *<Your_Product_Name>*.Types.ps1xml.</span></span>

<span data-ttu-id="11ce0-265">たとえば、スクリプトプロパティを追加して、 `Mode` ファイルの[](/dotnet/api/System.IO.FileInfo)属性をより明確に表示することができます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-265">For example, you could add a `Mode` script property to the [System.IO.FileInfo](/dotnet/api/System.IO.FileInfo) type to display the attributes of a file more clearly.</span></span> <span data-ttu-id="11ce0-266">また、alias プロパティを system.string 型に追加して、 `Count` (ではなく) そのプロパティ名を一貫して使用できるようにすることもでき[ます。](/dotnet/api/System.Array) `Length`</span><span class="sxs-lookup"><span data-stu-id="11ce0-266">Additionally, you could add a `Count` alias property to the [System.Array](/dotnet/api/System.Array) type to allow the consistent use of that property name (instead of `Length`).</span></span>

##### <a name="implement-the-icomparable-interface"></a><span data-ttu-id="11ce0-267">IComparable インターフェイスを実装する</span><span class="sxs-lookup"><span data-stu-id="11ce0-267">Implement the IComparable Interface</span></span>

<span data-ttu-id="11ce0-268">すべての出力オブジェクトに対して [system.icomparable](/dotnet/api/System.IComparable) インターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-268">Implement a [System.IComparable](/dotnet/api/System.IComparable) interface on all output objects.</span></span>
<span data-ttu-id="11ce0-269">これにより、さまざまな並べ替えおよび分析のコマンドレットに出力オブジェクトを簡単にパイプできます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-269">This allows the output objects to be easily piped to various sorting and analysis cmdlets.</span></span>

##### <a name="update-display-information"></a><span data-ttu-id="11ce0-270">表示情報の更新</span><span class="sxs-lookup"><span data-stu-id="11ce0-270">Update Display Information</span></span>

<span data-ttu-id="11ce0-271">オブジェクトの表示で予期した結果が得られない場合は、 *\<YourProductName>* そのオブジェクトのカスタム.Format.ps1xml ファイルを作成します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-271">If the display for an object does not provide the expected results, create a custom *\<YourProductName>*.Format.ps1xml file for that object.</span></span>

### <a name="support-well-defined-pipeline-input-sc02"></a><span data-ttu-id="11ce0-272">適切に定義されたパイプライン入力のサポート (SC02)</span><span class="sxs-lookup"><span data-stu-id="11ce0-272">Support Well Defined Pipeline Input (SC02)</span></span>

#### <a name="implement-for-the-middle-of-a-pipeline"></a><span data-ttu-id="11ce0-273">パイプラインの中間に実装する</span><span class="sxs-lookup"><span data-stu-id="11ce0-273">Implement for the Middle of a Pipeline</span></span>

<span data-ttu-id="11ce0-274">パイプラインの途中から呼び出されることを前提としてコマンドレットを実装します (つまり、他のコマンドレットが入力を生成したり、出力を使用したりします)。</span><span class="sxs-lookup"><span data-stu-id="11ce0-274">Implement a cmdlet assuming that it will be called from the middle of a pipeline (that is, other cmdlets will produce its input or consume its output).</span></span> <span data-ttu-id="11ce0-275">たとえば、 `Get-Process` コマンドレットがデータを生成するため、パイプラインの最初のコマンドレットとしてのみ使用されるとします。</span><span class="sxs-lookup"><span data-stu-id="11ce0-275">For example, you might assume that the `Get-Process` cmdlet, because it generates data, is used only as the first cmdlet in a pipeline.</span></span>
<span data-ttu-id="11ce0-276">ただし、このコマンドレットはパイプラインの途中で設計されているため、このコマンドレットを使用すると、パイプライン内の前のコマンドレットまたはデータで、取得するプロセスを指定できます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-276">However, because this cmdlet is designed for the middle of a pipeline, this cmdlet allows previous cmdlets or data in the pipeline to specify the processes to retrieve.</span></span>

#### <a name="support-input-from-the-pipeline"></a><span data-ttu-id="11ce0-277">パイプラインからの入力のサポート</span><span class="sxs-lookup"><span data-stu-id="11ce0-277">Support Input from the Pipeline</span></span>

<span data-ttu-id="11ce0-278">コマンドレットの各パラメーターセットに、パイプラインからの入力をサポートするパラメーターを少なくとも1つ含めます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-278">In each parameter set for a cmdlet, include at least one parameter that supports input from the pipeline.</span></span> <span data-ttu-id="11ce0-279">パイプライン入力のサポートにより、ユーザーはデータまたはオブジェクトを取得し、正しいパラメーターセットに送信し、結果をコマンドレットに直接渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-279">Support for pipeline input allows the user to retrieve data or objects, to send them to the correct parameter set, and to pass the results directly to a cmdlet.</span></span>

<span data-ttu-id="11ce0-280">**パラメーター属性に** `ValueFromPipeline` キーワード、 `ValueFromPipelineByPropertyName` キーワード属性、またはその両方のキーワードが宣言内に含まれている場合、パラメーターはパイプラインからの入力を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-280">A parameter accepts input from the pipeline if the **Parameter** attribute includes the `ValueFromPipeline` keyword, the `ValueFromPipelineByPropertyName` keyword attribute, or both keywords in its declaration.</span></span> <span data-ttu-id="11ce0-281">パラメーターセット内のパラメーターでキーワードまたはキーワードがサポートされていない場合は、 `ValueFromPipeline` `ValueFromPipelineByPropertyName` コマンドレットを別のコマンドレットの後に配置することはできません。これは、パイプラインの入力を無視するためです。</span><span class="sxs-lookup"><span data-stu-id="11ce0-281">If none of the parameters in a parameter set support the `ValueFromPipeline` or `ValueFromPipelineByPropertyName` keywords, the cmdlet cannot meaningfully be placed after another cmdlet because it will ignore any pipeline input.</span></span>

#### <a name="support-the-processrecord-method"></a><span data-ttu-id="11ce0-282">ProcessRecord メソッドのサポート</span><span class="sxs-lookup"><span data-stu-id="11ce0-282">Support the ProcessRecord Method</span></span>

<span data-ttu-id="11ce0-283">パイプラインで前のコマンドレットのすべてのレコードを受け入れるには、コマンドレットで [、system.object メソッドを](/dotnet/api/System.Management.Automation.Cmdlet.ProcessRecord) 実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-283">To accept all the records from the preceding cmdlet in the pipeline, your cmdlet must implement the [System.Management.Automation.Cmdlet.ProcessRecord](/dotnet/api/System.Management.Automation.Cmdlet.ProcessRecord) method.</span></span> <span data-ttu-id="11ce0-284">Windows PowerShell は、コマンドレットに送信されるすべてのレコードに対して、このメソッドを複数回呼び出します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-284">Windows PowerShell calls this method multiple times, once for every record that is sent to your cmdlet.</span></span>

### <a name="write-single-records-to-the-pipeline-sc03"></a><span data-ttu-id="11ce0-285">1つのレコードをパイプラインに書き込む (SC03)</span><span class="sxs-lookup"><span data-stu-id="11ce0-285">Write Single Records to the Pipeline (SC03)</span></span>

<span data-ttu-id="11ce0-286">コマンドレットによってオブジェクトが返された場合、コマンドレットでは、オブジェクトが生成されるとすぐに書き込みます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-286">When a cmdlet returns objects, the cmdlet should write the objects immediately as they are generated.</span></span> <span data-ttu-id="11ce0-287">コマンドレットでは、これらを組み合わせた配列にバッファーするためにそれらを保持することはできません。</span><span class="sxs-lookup"><span data-stu-id="11ce0-287">The cmdlet should not hold them in order to buffer them into a combined array.</span></span> <span data-ttu-id="11ce0-288">オブジェクトを入力として受け取るコマンドレットは、遅延なしで出力オブジェクトを処理、表示、または処理し、表示できるようになります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-288">The cmdlets that receive the objects as input will then be able to process, display, or process and display the output objects without delay.</span></span> <span data-ttu-id="11ce0-289">出力オブジェクトを一度に1つずつ生成するコマンドレットは、 [WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-289">A cmdlet that generates output objects one at a time should call the [System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) method.</span></span> <span data-ttu-id="11ce0-290">出力オブジェクトをバッチで生成するコマンドレット (たとえば、基になる API が出力オブジェクトの配列を返すため) は、2番目のパラメーターをに設定して [WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) メソッドを呼び出す必要があり `true` ます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-290">A cmdlet that generates output objects in batches (for example, because an underlying API returns an array of output objects) should call the [System.Management.Automation.Cmdlet.WriteObject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) Method with its second parameter set to `true`.</span></span>

### <a name="make-cmdlets-case-insensitive-and-case-preserving-sc04"></a><span data-ttu-id="11ce0-291">コマンドレットの Case-Insensitive と Case-Preserving (SC04) を作成する</span><span class="sxs-lookup"><span data-stu-id="11ce0-291">Make Cmdlets Case-Insensitive and Case-Preserving (SC04)</span></span>

<span data-ttu-id="11ce0-292">既定では、Windows PowerShell 自体は大文字と小文字を区別しません。</span><span class="sxs-lookup"><span data-stu-id="11ce0-292">By default, Windows PowerShell itself is case-insensitive.</span></span> <span data-ttu-id="11ce0-293">ただし、既存の多くのシステムを処理するため、Windows PowerShell では、操作と互換性のために大文字と小文字が維持されます。</span><span class="sxs-lookup"><span data-stu-id="11ce0-293">However, because it deals with many preexisting systems, Windows PowerShell does preserve case for ease of operation and compatibility.</span></span>
<span data-ttu-id="11ce0-294">つまり、文字が大文字で指定されている場合、Windows PowerShell はそれを大文字で保持します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-294">In other words, if a character is supplied in uppercase letters, Windows PowerShell keeps it in uppercase letters.</span></span> <span data-ttu-id="11ce0-295">システムが正常に機能するためには、コマンドレットでこの規則に従う必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-295">For systems to work well, a cmdlet needs to follow this convention.</span></span> <span data-ttu-id="11ce0-296">可能であれば、大文字と小文字を区別しない方法で動作します。</span><span class="sxs-lookup"><span data-stu-id="11ce0-296">If possible, it should operate in a case-insensitive way.</span></span> <span data-ttu-id="11ce0-297">ただし、後でコマンドまたはパイプラインで実行されるコマンドレットの場合は、元のケースを保持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="11ce0-297">It should, however, preserve the original case for cmdlets that occur later in a command or in the pipeline.</span></span>

## <a name="see-also"></a><span data-ttu-id="11ce0-298">参照</span><span class="sxs-lookup"><span data-stu-id="11ce0-298">See Also</span></span>

[<span data-ttu-id="11ce0-299">必要な開発ガイドライン</span><span class="sxs-lookup"><span data-stu-id="11ce0-299">Required Development Guidelines</span></span>](./required-development-guidelines.md)

[<span data-ttu-id="11ce0-300">お勧めする開発ガイドライン</span><span class="sxs-lookup"><span data-stu-id="11ce0-300">Advisory Development Guidelines</span></span>](./advisory-development-guidelines.md)

[<span data-ttu-id="11ce0-301">Windows PowerShell コマンドレットの記述</span><span class="sxs-lookup"><span data-stu-id="11ce0-301">Writing a Windows PowerShell Cmdlet</span></span>](./writing-a-windows-powershell-cmdlet.md)
