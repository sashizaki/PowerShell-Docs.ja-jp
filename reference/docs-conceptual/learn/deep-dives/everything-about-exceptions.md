---
title: 例外について知りたかったことのすべて
description: エラー処理は、コードを記述するときにはなくてはならないものです。
ms.date: 05/23/2020
ms.custom: contributor-KevinMarquette
ms.openlocfilehash: 3ecb1669fa8d58bc742d4e8e77051b3ace4452a0
ms.sourcegitcommit: 4a40e3ea3601c02366be3495a5dcc7f4cac9f1ea
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/03/2020
ms.locfileid: "84337184"
---
# <a name="everything-you-wanted-to-know-about-exceptions"></a><span data-ttu-id="b34ae-103">例外について知りたかったことのすべて</span><span class="sxs-lookup"><span data-stu-id="b34ae-103">Everything you wanted to know about exceptions</span></span>

<span data-ttu-id="b34ae-104">エラー処理は、コードを記述するときにはなくてはならないものです。</span><span class="sxs-lookup"><span data-stu-id="b34ae-104">Error handling is just part of life when it comes to writing code.</span></span> <span data-ttu-id="b34ae-105">多くの場合、予期される動作になっているかどうか、条件を確認し、検証することができます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-105">We can often check and validate conditions for expected behavior.</span></span> <span data-ttu-id="b34ae-106">予期しないことが発生した場合、例外処理を利用します。</span><span class="sxs-lookup"><span data-stu-id="b34ae-106">When the unexpected happens, we turn to exception handling.</span></span> <span data-ttu-id="b34ae-107">他のユーザーのコードにより生成された例外を簡単に処理でき、また他のユーザーが処理するための独自の例外を生成することもできます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-107">You can easily handle exceptions generated by other people's code or you can generate your own exceptions for others to handle.</span></span>

> [!NOTE]
> <span data-ttu-id="b34ae-108">この記事の[オリジナル バージョン][]は、[@KevinMarquette][] 氏のブログ記事です。</span><span class="sxs-lookup"><span data-stu-id="b34ae-108">The [original version][] of this article appeared on the blog written by [@KevinMarquette][].</span></span> <span data-ttu-id="b34ae-109">このコンテンツを共有してくださった Kevin 氏に、PowerShell チームより感謝を申し上げます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-109">The PowerShell team thanks Kevin for sharing this content with us.</span></span> <span data-ttu-id="b34ae-110">[PowerShellExplained.com][] のブログをご確認ください。</span><span class="sxs-lookup"><span data-stu-id="b34ae-110">Please check out his blog at [PowerShellExplained.com][].</span></span>

## <a name="basic-terminology"></a><span data-ttu-id="b34ae-111">基本的な用語</span><span class="sxs-lookup"><span data-stu-id="b34ae-111">Basic terminology</span></span>

<span data-ttu-id="b34ae-112">この記事に進む前に、いくつかの基本的な用語について説明する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-112">We need to cover some basic terms before we jump into this one.</span></span>

### <a name="exception"></a><span data-ttu-id="b34ae-113">例外</span><span class="sxs-lookup"><span data-stu-id="b34ae-113">Exception</span></span>

<span data-ttu-id="b34ae-114">例外とは、通常のエラー処理で問題に対処できない場合に作成されるイベントのようなものです。</span><span class="sxs-lookup"><span data-stu-id="b34ae-114">An Exception is like an event that is created when normal error handling can't deal with the issue.</span></span>
<span data-ttu-id="b34ae-115">数値を 0 で除算することやメモリ不足などが、例外が作成されることになる例です。</span><span class="sxs-lookup"><span data-stu-id="b34ae-115">Trying to divide a number by zero or running out of memory are examples of something that creates an exception.</span></span> <span data-ttu-id="b34ae-116">場合によっては、使用しているコードの作成者が、特定の問題の発生時に例外を作成することがあります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-116">Sometimes the author of the code you're using creates exceptions for certain issues when they happen.</span></span>

### <a name="throw-and-catch"></a><span data-ttu-id="b34ae-117">スローとキャッチ</span><span class="sxs-lookup"><span data-stu-id="b34ae-117">Throw and Catch</span></span>

<span data-ttu-id="b34ae-118">例外が発生することを、例外がスローされると言います。</span><span class="sxs-lookup"><span data-stu-id="b34ae-118">When an exception happens, we say that an exception is thrown.</span></span> <span data-ttu-id="b34ae-119">スローされた例外を処理するには、それをキャッチする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-119">To handle a thrown exception, you need to catch it.</span></span> <span data-ttu-id="b34ae-120">例外がスローされ、キャッチされない場合、スクリプトの実行が停止されます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-120">If an exception is thrown and it isn't caught by something, the script stops executing.</span></span>

### <a name="the-call-stack"></a><span data-ttu-id="b34ae-121">コール スタック</span><span class="sxs-lookup"><span data-stu-id="b34ae-121">The call stack</span></span>

<span data-ttu-id="b34ae-122">コール スタックは、互いに呼び出された関数の一覧です。</span><span class="sxs-lookup"><span data-stu-id="b34ae-122">The call stack is the list of functions that have called each other.</span></span> <span data-ttu-id="b34ae-123">関数が呼び出されると、それがスタックまたはリストの先頭に追加されます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-123">When a function is called, it gets added to the stack or the top of the list.</span></span> <span data-ttu-id="b34ae-124">関数が終了するか、関数から戻ると、それはスタックから削除されます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-124">When the function exits or returns, it is removed from the stack.</span></span>

<span data-ttu-id="b34ae-125">例外がスローされると、例外ハンドラーがそれをキャッチするためにコール スタックがチェックされます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-125">When an exception is thrown, that call stack is checked in order for an exception handler to catch it.</span></span>

### <a name="terminating-and-non-terminating-errors"></a><span data-ttu-id="b34ae-126">終了エラーと終了しないエラー</span><span class="sxs-lookup"><span data-stu-id="b34ae-126">Terminating and non-terminating errors</span></span>

<span data-ttu-id="b34ae-127">例外は通常、終了エラーです。</span><span class="sxs-lookup"><span data-stu-id="b34ae-127">An exception is generally a terminating error.</span></span> <span data-ttu-id="b34ae-128">スローされた例外は、キャッチされるか、または現在の実行を終了します。</span><span class="sxs-lookup"><span data-stu-id="b34ae-128">A thrown exception is either be caught or it terminates the current execution.</span></span> <span data-ttu-id="b34ae-129">既定では、終了しないエラーは `Write-Error` によって生成され、例外をスローすることなく出力ストリームにエラーを追加します。</span><span class="sxs-lookup"><span data-stu-id="b34ae-129">By default, a non-terminating error is generated by `Write-Error` and it adds an error to the output stream without throwing an exception.</span></span>

<span data-ttu-id="b34ae-130">これを指摘している理由は、`Write-Error` とその他の終了しないエラーでは `catch` がトリガーされないためです。</span><span class="sxs-lookup"><span data-stu-id="b34ae-130">I point this out because `Write-Error` and other non-terminating errors do not trigger the `catch`.</span></span>

### <a name="swallowing-an-exception"></a><span data-ttu-id="b34ae-131">例外を飲み込む</span><span class="sxs-lookup"><span data-stu-id="b34ae-131">Swallowing an exception</span></span>

<span data-ttu-id="b34ae-132">これは、エラーを抑止するためだけにキャッチすることです。</span><span class="sxs-lookup"><span data-stu-id="b34ae-132">This is when you catch an error just to suppress it.</span></span> <span data-ttu-id="b34ae-133">これは、問題のトラブルシューティングを非常に困難にする可能性があるため、慎重に利用してください。</span><span class="sxs-lookup"><span data-stu-id="b34ae-133">Do this with caution because it can make troubleshooting issues very difficult.</span></span>

## <a name="basic-command-syntax"></a><span data-ttu-id="b34ae-134">基本的なコマンド構文</span><span class="sxs-lookup"><span data-stu-id="b34ae-134">Basic command syntax</span></span>

<span data-ttu-id="b34ae-135">ここでは、PowerShell で使用される基本的な例外処理構文の概要を示します。</span><span class="sxs-lookup"><span data-stu-id="b34ae-135">Here is a quick overview of the basic exception handling syntax used in PowerShell.</span></span>

### <a name="throw"></a><span data-ttu-id="b34ae-136">Throw</span><span class="sxs-lookup"><span data-stu-id="b34ae-136">Throw</span></span>

<span data-ttu-id="b34ae-137">独自の例外イベントを作成するには、`throw` キーワードを使用して例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="b34ae-137">To create our own exception event, we throw an exception with the `throw` keyword.</span></span>

```powershell
function Start-Something
{
    throw "Bad thing happened"
}
```

<span data-ttu-id="b34ae-138">これにより、終了エラーであるランタイム例外が作成されます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-138">This creates a runtime exception that is a terminating error.</span></span> <span data-ttu-id="b34ae-139">これは、呼び出し元の関数の `catch` によって処理されるか、またはこのようなメッセージを使用してスクリプトを終了します。</span><span class="sxs-lookup"><span data-stu-id="b34ae-139">It's handled by a `catch` in a calling function or exits the script with a message like this.</span></span>

```powershell
PS> Start-Something

Bad thing happened
At line:1 char:1
+ throw "Bad thing happened"
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (Bad thing happened:String) [], RuntimeException
    + FullyQualifiedErrorId : Bad thing happened
```

#### <a name="write-error--erroraction-stop"></a><span data-ttu-id="b34ae-140">Write-Error -ErrorAction Stop</span><span class="sxs-lookup"><span data-stu-id="b34ae-140">Write-Error -ErrorAction Stop</span></span>

<span data-ttu-id="b34ae-141">既定では `Write-Error` が終了エラーをスローしないことを説明しました。</span><span class="sxs-lookup"><span data-stu-id="b34ae-141">I mentioned that `Write-Error` doesn't throw a terminating error by default.</span></span> <span data-ttu-id="b34ae-142">`-ErrorAction Stop` を指定した場合、`Write-Error` によって、`catch` で処理できる終了エラーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-142">If you specify `-ErrorAction Stop`, `Write-Error`generates a terminating error that can be handled with a `catch`.</span></span>

```powershell
Write-Error -Message "Houston, we have a problem." -ErrorAction Stop
```

<span data-ttu-id="b34ae-143">`-ErrorAction Stop` をこのように使用する方法について助言してくれた、Lee Daily 氏に感謝申し上げます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-143">Thank you to Lee Daily for reminding about using `-ErrorAction Stop` this way.</span></span>

#### <a name="cmdlet--erroraction-stop"></a><span data-ttu-id="b34ae-144">コマンドレット -ErrorAction Stop</span><span class="sxs-lookup"><span data-stu-id="b34ae-144">Cmdlet -ErrorAction Stop</span></span>

<span data-ttu-id="b34ae-145">高度な関数またはコマンドレットで `-ErrorAction Stop` を指定すると、すべての `Write-Error` ステートメントが、実行を停止するか `catch` によって処理できる終了エラーになります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-145">If you specify `-ErrorAction Stop` on any advanced function or cmdlet, it turns all `Write-Error` statements into terminating errors that stop execution or that can be handled by a `catch`.</span></span>

```powershell
Start-Something -ErrorAction Stop
```

### <a name="trycatch"></a><span data-ttu-id="b34ae-146">Try/Catch</span><span class="sxs-lookup"><span data-stu-id="b34ae-146">Try/Catch</span></span>

<span data-ttu-id="b34ae-147">PowerShell (およびその他の多くの言語) での例外処理のしくみでは、最初にコードのセクションを `try` し、エラーがスローされた場合にそれを `catch` できます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-147">The way exception handling works in PowerShell (and many other languages) is that you first `try` a section of code and if it throws an error, you can `catch` it.</span></span> <span data-ttu-id="b34ae-148">以下に簡単なサンプルを示します。</span><span class="sxs-lookup"><span data-stu-id="b34ae-148">Here is a quick sample.</span></span>

```powershell
try
{
    Start-Something
}
catch
{
    Write-Output "Something threw an exception"
}

try
{
    Start-Something -ErrorAction Stop
}
catch
{
    Write-Output "Something threw an exception or used Write-Error"
}
```

<span data-ttu-id="b34ae-149">`catch` スクリプトは、終了エラーが発生した場合にのみ実行されます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-149">The `catch` script only runs if there's a terminating error.</span></span> <span data-ttu-id="b34ae-150">`try` が正常に実行された場合は、`catch` はスキップされます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-150">If the `try` executes correctly, then it skips over the `catch`.</span></span>

### <a name="tryfinally"></a><span data-ttu-id="b34ae-151">Try/Finally</span><span class="sxs-lookup"><span data-stu-id="b34ae-151">Try/Finally</span></span>

<span data-ttu-id="b34ae-152">エラーを処理する必要はなくても、例外が発生したかどうかにかかわらず、何らかのコードを実行する必要があることがあります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-152">Sometimes you don't need to handle an error but still need some code to execute if an exception happens or not.</span></span> <span data-ttu-id="b34ae-153">`finally` スクリプトはまさにこのためにあります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-153">A `finally` script does exactly that.</span></span>

<span data-ttu-id="b34ae-154">次の例を見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="b34ae-154">Take a look at this example:</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
$command.Connection.Open()
$command.ExecuteNonQuery()
$command.Connection.Close()
```

<span data-ttu-id="b34ae-155">リソースを開いたり、リソースに接続したりするときは常に、リソースを閉じる必要があります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-155">Anytime you open or connect to a resource, you should close it.</span></span> <span data-ttu-id="b34ae-156">`ExecuteNonQuery()` が例外をスローした場合、接続は閉じられません。</span><span class="sxs-lookup"><span data-stu-id="b34ae-156">If the `ExecuteNonQuery()` throws an exception, the connection isn't closed.</span></span> <span data-ttu-id="b34ae-157">次に示すのは、同じコードの `try/finally` ブロック内です。</span><span class="sxs-lookup"><span data-stu-id="b34ae-157">Here is the same code inside a `try/finally` block.</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
try
{
    $command.Connection.Open()
    $command.ExecuteNonQuery()
}
finally
{
    $command.Connection.Close()
}
```

<span data-ttu-id="b34ae-158">この例では、エラーが発生した場合に接続が閉じられます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-158">In this example, the connection is closed if there's an error.</span></span> <span data-ttu-id="b34ae-159">エラーがない場合にも閉じられます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-159">It also is closed if there's no error.</span></span> <span data-ttu-id="b34ae-160">`finally` スクリプトは毎回実行されます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-160">The `finally` script runs every time.</span></span>

<span data-ttu-id="b34ae-161">例外をキャッチしていないため、コール スタックに伝達されます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-161">Because you're not catching the exception, it still gets propagated up the call stack.</span></span>

### <a name="trycatchfinally"></a><span data-ttu-id="b34ae-162">Try/Catch/Finally</span><span class="sxs-lookup"><span data-stu-id="b34ae-162">Try/Catch/Finally</span></span>

<span data-ttu-id="b34ae-163">`catch` と `finally` を一緒に使用することはまったく問題ありません。</span><span class="sxs-lookup"><span data-stu-id="b34ae-163">It's perfectly valid to use `catch` and `finally` together.</span></span> <span data-ttu-id="b34ae-164">ほとんどの場合、どちらか一方を使用しますが、両方を使用するシナリオもあり得ます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-164">Most of the time you'll use one or the other, but you may find scenarios where you use both.</span></span>

## <a name="psitem"></a><span data-ttu-id="b34ae-165">$PSItem</span><span class="sxs-lookup"><span data-stu-id="b34ae-165">$PSItem</span></span>

<span data-ttu-id="b34ae-166">基本についての説明が終わったので、もう少し掘り下げてみましょう。</span><span class="sxs-lookup"><span data-stu-id="b34ae-166">Now that we got the basics out of the way, we can dig a little deeper.</span></span>

<span data-ttu-id="b34ae-167">`catch` ブロック内には、例外の詳細を含む `ErrorRecord` 型の自動変数 (`$PSItem` または `$_`) があります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-167">Inside the `catch` block, there's an automatic variable (`$PSItem` or `$_`) of type `ErrorRecord` that contains the details about the exception.</span></span> <span data-ttu-id="b34ae-168">主要なプロパティのいくつかについて簡単に説明します。</span><span class="sxs-lookup"><span data-stu-id="b34ae-168">Here is a quick overview of some of the key properties.</span></span>

<span data-ttu-id="b34ae-169">これらの例では、`ReadAllText` で無効なパスを使用して、この例外を生成しています。</span><span class="sxs-lookup"><span data-stu-id="b34ae-169">For these examples, I used an invalid path in `ReadAllText` to generate this exception.</span></span>

```powershell
[System.IO.File]::ReadAllText( '\\test\no\filefound.log')
```

### <a name="psitemtostring"></a><span data-ttu-id="b34ae-170">PSItem.ToString()</span><span class="sxs-lookup"><span data-stu-id="b34ae-170">PSItem.ToString()</span></span>

<span data-ttu-id="b34ae-171">これにより、ログ記録と一般出力で使用する簡潔なメッセージが得られます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-171">This gives you the cleanest message to use in logging and general output.</span></span> <span data-ttu-id="b34ae-172">`$PSItem` が文字列内に配置されている場合、`ToString()` は自動的に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-172">`ToString()` is automatically called if `$PSItem` is placed inside a string.</span></span>

```powershell
catch
{
    Write-Output "Ran into an issue: $($PSItem.ToString())"
}

catch
{
    Write-Output "Ran into an issue: $PSItem"
}
```

### <a name="psiteminvocationinfo"></a><span data-ttu-id="b34ae-173">$PSItem.InvocationInfo</span><span class="sxs-lookup"><span data-stu-id="b34ae-173">$PSItem.InvocationInfo</span></span>

<span data-ttu-id="b34ae-174">このプロパティには、PowerShell によって収集される、例外がスローされた関数またはスクリプトに関する追加情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="b34ae-174">This property contains additional information collected by PowerShell about the function or script where the exception was thrown.</span></span> <span data-ttu-id="b34ae-175">これは、作成したサンプル例外の `InvocationInfo` です。</span><span class="sxs-lookup"><span data-stu-id="b34ae-175">Here is the `InvocationInfo` from the sample exception that I created.</span></span>

```powershell
PS> $PSItem.InvocationInfo | Format-List *

MyCommand             : Get-Resource
BoundParameters       : {}
UnboundArguments      : {}
ScriptLineNumber      : 5
OffsetInLine          : 5
ScriptName            : C:\blog\throwerror.ps1
Line                  :     Get-Resource
PositionMessage       : At C:\blog\throwerror.ps1:5 char:5
                        +     Get-Resource
                        +     ~~~~~~~~~~~~
PSScriptRoot          : C:\blog
PSCommandPath         : C:\blog\throwerror.ps1
InvocationName        : Get-Resource
```

<span data-ttu-id="b34ae-176">ここで重要な詳細は、`ScriptName`、コードの `Line`、および呼び出しが開始された `ScriptLineNumber` です。</span><span class="sxs-lookup"><span data-stu-id="b34ae-176">The important details here show the `ScriptName`, the `Line` of code and the `ScriptLineNumber` where the invocation started.</span></span>

### <a name="psitemscriptstacktrace"></a><span data-ttu-id="b34ae-177">$PSItem.ScriptStackTrace</span><span class="sxs-lookup"><span data-stu-id="b34ae-177">$PSItem.ScriptStackTrace</span></span>

<span data-ttu-id="b34ae-178">このプロパティは、例外が生成されたコードまでの関数呼び出しの順序を示します。</span><span class="sxs-lookup"><span data-stu-id="b34ae-178">This property shows the order of function calls that got you to the code where the exception was generated.</span></span>

```powershell
PS> $PSItem.ScriptStackTrace
at Get-Resource, C:\blog\throwerror.ps1: line 13
at Start-Something, C:\blog\throwerror.ps1: line 5
at <ScriptBlock>, C:\blog\throwerror.ps1: line 18
```

<span data-ttu-id="b34ae-179">ここでは同じスクリプトで関数の呼び出しを行っているだけですが、複数のスクリプトが関係している場合は呼び出しが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-179">I'm only making calls to functions in the same script but this would track the calls if multiple scripts were involved.</span></span>

### <a name="psitemexception"></a><span data-ttu-id="b34ae-180">$PSItem.Exception</span><span class="sxs-lookup"><span data-stu-id="b34ae-180">$PSItem.Exception</span></span>

<span data-ttu-id="b34ae-181">これは、スローされた実際の例外です。</span><span class="sxs-lookup"><span data-stu-id="b34ae-181">This is the actual exception that was thrown.</span></span>

#### <a name="psitemexceptionmessage"></a><span data-ttu-id="b34ae-182">$PSItem.Exception.Message</span><span class="sxs-lookup"><span data-stu-id="b34ae-182">$PSItem.Exception.Message</span></span>

<span data-ttu-id="b34ae-183">これは、例外について説明する一般的なメッセージであり、トラブルシューティングを行う際には適切な出発点となります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-183">This is the general message that describes the exception and is a good starting point when troubleshooting.</span></span> <span data-ttu-id="b34ae-184">ほとんどの例外には既定のメッセージがありますが、例外がスローされたときにカスタム値に設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-184">Most exceptions have a default message but can also be set to something custom when the exception is thrown.</span></span>

```powershell
PS> $PSItem.Exception.Message

Exception calling "ReadAllText" with "1" argument(s): "The network path was not found."
```

<span data-ttu-id="b34ae-185">これは、`ErrorRecord` にメッセージが 1 つも設定されていない場合に、`$PSItem.ToString()` を呼び出すときに返されるメッセージでもあります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-185">This is also the message returned when calling `$PSItem.ToString()` if there was not one set on the `ErrorRecord`.</span></span>

#### <a name="psitemexceptioninnerexception"></a><span data-ttu-id="b34ae-186">$PSItem.Exception.InnerException</span><span class="sxs-lookup"><span data-stu-id="b34ae-186">$PSItem.Exception.InnerException</span></span>

<span data-ttu-id="b34ae-187">例外には内部例外を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-187">Exceptions can contain inner exceptions.</span></span> <span data-ttu-id="b34ae-188">これは多くの場合、呼び出しているコードが例外をキャッチし、別の例外をスローする場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="b34ae-188">This is often the case when the code you're calling catches an exception and throws a different exception.</span></span> <span data-ttu-id="b34ae-189">元の例外は、新しい例外の内部に配置されます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-189">The original exception is placed inside the new exception.</span></span>

```powershell
PS> $PSItem.Exception.InnerExceptionMessage
The network path was not found.
```

<span data-ttu-id="b34ae-190">これについては、例外の再スローについての説明でまた取り上げます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-190">I will revisit this later when I talk about re-throwing exceptions.</span></span>

#### <a name="psitemexceptionstacktrace"></a><span data-ttu-id="b34ae-191">$PSItem.Exception.StackTrace</span><span class="sxs-lookup"><span data-stu-id="b34ae-191">$PSItem.Exception.StackTrace</span></span>

<span data-ttu-id="b34ae-192">これは例外の `StackTrace` です。</span><span class="sxs-lookup"><span data-stu-id="b34ae-192">This is the `StackTrace` for the exception.</span></span> <span data-ttu-id="b34ae-193">上で `ScriptStackTrace` を示しましたが、これはマネージド コードの呼び出しが対象です。</span><span class="sxs-lookup"><span data-stu-id="b34ae-193">I showed a `ScriptStackTrace` above, but this one is for the calls to managed code.</span></span>

```Output
at System.IO.FileStream.Init(String path, FileMode mode, FileAccess access, Int32 rights, Boolean
 useRights, FileShare share, Int32 bufferSize, FileOptions options, SECURITY_ATTRIBUTES secAttrs,
 String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean checkHost)
at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32
 bufferSize, FileOptions options, String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean
 checkHost)
at System.IO.StreamReader..ctor(String path, Encoding encoding, Boolean detectEncodingFromByteOrderMarks,
 Int32 bufferSize, Boolean checkHost)
at System.IO.File.InternalReadAllText(String path, Encoding encoding, Boolean checkHost)
at CallSite.Target(Closure , CallSite , Type , String )
```

<span data-ttu-id="b34ae-194">このスタック トレースは、イベントがマネージド コードからスローされた場合にのみ取得されます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-194">You only get this stack trace when the event is thrown from managed code.</span></span> <span data-ttu-id="b34ae-195">.NET Framework 関数を直接呼び出しているため、この例で確認できるのはこれがすべてです。</span><span class="sxs-lookup"><span data-stu-id="b34ae-195">I'm calling a .NET framework function directly so that is all we can see in this example.</span></span> <span data-ttu-id="b34ae-196">一般的には、スタック トレースを確認するときは、コードが停止し、システム コールが開始された場所を探します。</span><span class="sxs-lookup"><span data-stu-id="b34ae-196">Generally when you're looking at a stack trace, you're looking for where your code stops and the system calls begin.</span></span>

## <a name="working-with-exceptions"></a><span data-ttu-id="b34ae-197">例外の処理</span><span class="sxs-lookup"><span data-stu-id="b34ae-197">Working with exceptions</span></span>

<span data-ttu-id="b34ae-198">例外には、基本構文と例外プロパティ以外にもさらに説明が必要です。</span><span class="sxs-lookup"><span data-stu-id="b34ae-198">There is more to exceptions than the basic syntax and exception properties.</span></span>

### <a name="catching-typed-exceptions"></a><span data-ttu-id="b34ae-199">型指定された例外のキャッチ</span><span class="sxs-lookup"><span data-stu-id="b34ae-199">Catching typed exceptions</span></span>

<span data-ttu-id="b34ae-200">キャッチする例外を選択することができます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-200">You can be selective with the exceptions that you catch.</span></span> <span data-ttu-id="b34ae-201">例外には型があり、キャッチする例外の型を指定できます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-201">Exceptions have a type and you can specify the type of exception you want to catch.</span></span>

```powershell
try
{
    Start-Something -Path $path
}
catch [System.IO.FileNotFoundException]
{
    Write-Output "Could not find $path"
}
catch [System.IO.IOException]
{
        Write-Output "IO error with the file: $path"
}
```

<span data-ttu-id="b34ae-202">例外の型は、例外に一致するものが見つかるまで `catch` ブロックごとにチェックされます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-202">The exception type is checked for each `catch` block until one is found that matches your exception.</span></span>
<span data-ttu-id="b34ae-203">例外は他の例外から継承できることを認識しておくことが重要です。</span><span class="sxs-lookup"><span data-stu-id="b34ae-203">It's important to realize that exceptions can inherit from other exceptions.</span></span> <span data-ttu-id="b34ae-204">上記の例では `FileNotFoundException` は `IOException` から継承されています。</span><span class="sxs-lookup"><span data-stu-id="b34ae-204">In the example above, `FileNotFoundException` inherits from `IOException`.</span></span> <span data-ttu-id="b34ae-205">そのため、`IOException` が最初に発生した場合は、代わりにこれが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-205">So if the `IOException` was first, then it would get called instead.</span></span> <span data-ttu-id="b34ae-206">複数の一致がある場合でも、1 つの catch ブロックのみが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-206">Only one catch block is invoked even if there are multiple matches.</span></span>

<span data-ttu-id="b34ae-207">`System.IO.PathTooLongException` が発生した場合、`IOException` は一致しますが、`InsufficientMemoryException` が発生した場合は、何もキャッチされずにスタックの上位に伝達されます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-207">If we had a `System.IO.PathTooLongException`, the `IOException` would match but if we had a `InsufficientMemoryException` then nothing would catch it and it would propagate up the stack.</span></span>

### <a name="catch-multiple-types-at-once"></a><span data-ttu-id="b34ae-208">複数の型を一度にキャッチする</span><span class="sxs-lookup"><span data-stu-id="b34ae-208">Catch multiple types at once</span></span>

<span data-ttu-id="b34ae-209">同じ `catch` ステートメントを使用して、複数の例外の型をキャッチすることができます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-209">It's possible to catch multiple exception types with the same `catch` statement.</span></span>

```powershell
try
{
    Start-Something -Path $path -ErrorAction Stop
}
catch [System.IO.DirectoryNotFoundException],[System.IO.FileNotFoundException]
{
    Write-Output "The path or file was not found: [$path]"
}
catch [System.IO.IOException]
{
    Write-Output "IO error with the file: [$path]"
}
```

<span data-ttu-id="b34ae-210">この追加を提案していただいた `/u/Sheppard_Ra` にお礼を申し上げます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-210">Thank you `/u/Sheppard_Ra` for suggesting this addition.</span></span>

### <a name="throwing-typed-exceptions"></a><span data-ttu-id="b34ae-211">型指定された例外のスロー</span><span class="sxs-lookup"><span data-stu-id="b34ae-211">Throwing typed exceptions</span></span>

<span data-ttu-id="b34ae-212">PowerShell では、型指定された例外をスローできます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-212">You can throw typed exceptions in PowerShell.</span></span> <span data-ttu-id="b34ae-213">通常は `throw` を文字列と共に呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b34ae-213">Instead of calling `throw` with a string:</span></span>

```powershell
throw "Could not find: $path"
```

<span data-ttu-id="b34ae-214">その代わりに、次のような例外アクセラレータを使用します。</span><span class="sxs-lookup"><span data-stu-id="b34ae-214">Use an exception accelerator like this:</span></span>

```powershell
throw [System.IO.FileNotFoundException] "Could not find: $path"
```

<span data-ttu-id="b34ae-215">ただし、この方法の場合はメッセージを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-215">But you have to specify a message when you do it that way.</span></span>

<span data-ttu-id="b34ae-216">スローする例外の新しいインスタンスを作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-216">You can also create a new instance of an exception to be thrown.</span></span> <span data-ttu-id="b34ae-217">これを行う場合はメッセージは省略可能になります。これは、すべての組み込み例外に対するシステムの既定のメッセージがあるためです。</span><span class="sxs-lookup"><span data-stu-id="b34ae-217">The message is optional when you do this because the system has default messages for all built-in exceptions.</span></span>

```powershell
throw [System.IO.FileNotFoundException]::new()
throw [System.IO.FileNotFoundException]::new("Could not find path: $path")
```

<span data-ttu-id="b34ae-218">PowerShell 5.0 以降を使用していない場合は、以前の `New-Object` のアプローチを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-218">If you're not using PowerShell 5.0 or higher, you must use the older `New-Object` approach.</span></span>

```powershell
throw (New-Object -TypeName System.IO.FileNotFoundException )
throw (New-Object -TypeName System.IO.FileNotFoundException -ArgumentList "Could not find path: $path")
```

<span data-ttu-id="b34ae-219">型指定された例外を使用すると、自分または他のユーザーが前のセクションで説明した型によって例外をキャッチできます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-219">By using a typed exception, you (or others) can catch the exception by the type as mentioned in the previous section.</span></span>

#### <a name="write-error--exception"></a><span data-ttu-id="b34ae-220">Write-Error -Exception</span><span class="sxs-lookup"><span data-stu-id="b34ae-220">Write-Error -Exception</span></span>

<span data-ttu-id="b34ae-221">これらの型指定された例外を `Write-Error` に追加しても、例外の型別にエラーを `catch` できます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-221">We can add these typed exceptions to `Write-Error` and we can still `catch` the errors by exception type.</span></span> <span data-ttu-id="b34ae-222">以下の例のように `Write-Error` を使用します。</span><span class="sxs-lookup"><span data-stu-id="b34ae-222">Use `Write-Error` like in these examples:</span></span>

```powershell
# with normal message
Write-Error -Message "Could not find path: $path" -Exception ([System.IO.FileNotFoundException]::new()) -ErrorAction Stop

# With message inside new exception
Write-Error -Exception ([System.IO.FileNotFoundException]::new("Could not find path: $path")) -ErrorAction Stop

# Pre PS 5.0
Write-Error -Exception ([System.IO.FileNotFoundException]"Could not find path: $path") -ErrorAction Stop

Write-Error -Message "Could not find path: $path" -Exception ( New-Object -TypeName System.IO.FileNotFoundException ) -ErrorAction Stop
```

<span data-ttu-id="b34ae-223">そうすると、次のようにしてこれをキャッチできます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-223">Then we can catch it like this:</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Log $PSItem.ToString()
}
```

#### <a name="the-big-list-of-net-exceptions"></a><span data-ttu-id="b34ae-224">.NET 例外の巨大な一覧</span><span class="sxs-lookup"><span data-stu-id="b34ae-224">The big list of .NET exceptions</span></span>

<span data-ttu-id="b34ae-225">私は [Reddit/r/PowerShell コミュニティ][] の支援を得て、この投稿の補足となる、何百もの .NET 例外が含まれているマスター リストをまとめました。</span><span class="sxs-lookup"><span data-stu-id="b34ae-225">I compiled a master list with the help of the [Reddit/r/PowerShell community][] that contains hundreds of .NET exceptions to complement this post.</span></span>

- <span data-ttu-id="b34ae-226">[.NET 例外の巨大な一覧][]</span><span class="sxs-lookup"><span data-stu-id="b34ae-226">[The big list of .NET exceptions][]</span></span>

<span data-ttu-id="b34ae-227">まず、このリストを検索して、自分の状況に適していると思われる例外を見つけます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-227">I start by searching that list for exceptions that feel like they would be a good fit for my situation.</span></span> <span data-ttu-id="b34ae-228">基本の `System` 名前空間の例外を使用するようにしてください。</span><span class="sxs-lookup"><span data-stu-id="b34ae-228">You should try to use exceptions in the base `System` namespace.</span></span>

### <a name="exceptions-are-objects"></a><span data-ttu-id="b34ae-229">例外はオブジェクトである</span><span class="sxs-lookup"><span data-stu-id="b34ae-229">Exceptions are objects</span></span>

<span data-ttu-id="b34ae-230">多数の型指定された例外を使い始めるときは、それらがオブジェクトであることを忘れないでください。</span><span class="sxs-lookup"><span data-stu-id="b34ae-230">If you start using a lot of typed exceptions, remember that they are objects.</span></span> <span data-ttu-id="b34ae-231">異なる例外には、異なるコンストラクターとプロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-231">Different exceptions have different constructors and properties.</span></span> <span data-ttu-id="b34ae-232">[FileNotFoundException][] のドキュメントで `System.IO.FileNotFoundException` を参照すると、メッセージとファイル パスを渡すことができるのが分かります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-232">If we look at the [FileNotFoundException][] documentation for `System.IO.FileNotFoundException`, we see that we can pass in a message and a file path.</span></span>

```powershell
[System.IO.FileNotFoundException]::new("Could not find file", $path)
```

<span data-ttu-id="b34ae-233">また、そのファイル パスを公開する `FileName` プロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-233">And it has a `FileName` property that exposes that file path.</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Output $PSItem.Exception.FileName
}
```

<span data-ttu-id="b34ae-234">他のコンストラクターとオブジェクトのプロパティについては、[.NET ドキュメント][]を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b34ae-234">You should consult the [.NET documentation][] for other constructors and object properties.</span></span>

### <a name="re-throwing-an-exception"></a><span data-ttu-id="b34ae-235">例外を再スローする</span><span class="sxs-lookup"><span data-stu-id="b34ae-235">Re-throwing an exception</span></span>

<span data-ttu-id="b34ae-236">`catch` ブロックで実行するのが同じ例外の `throw` のみである場合は、`catch` しないでください。</span><span class="sxs-lookup"><span data-stu-id="b34ae-236">If all you're going to do in your `catch` block is `throw` the same exception, then don't `catch` it.</span></span> <span data-ttu-id="b34ae-237">例外を `catch` するのは、それが発生したときに処理または何らかのアクションを実行する場合のみにしてください。</span><span class="sxs-lookup"><span data-stu-id="b34ae-237">You should only `catch` an exception that you plan to handle or perform some action when it happens.</span></span>

<span data-ttu-id="b34ae-238">例外に対してアクションを実行しながら、同時にダウンストリームでそれを処理できるように例外を再スローすることが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-238">There are times where you want to perform an action on an exception but re-throw the exception so something downstream can deal with it.</span></span> <span data-ttu-id="b34ae-239">検出された場所の近くでメッセージを書き込んだり、問題をログに記録したりするが、問題の処理はスタックのさらに上で行うことができます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-239">We could write a message or log the problem close to where we discover it but handle the issue further up the stack.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw $PSItem
}
```

<span data-ttu-id="b34ae-240">興味深いことに、`catch` 内から `throw` を呼び出して、現在の例外を再スローすることができます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-240">Interestingly enough, we can call `throw` from within the `catch` and it re-throws the current exception.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw
}
```

<span data-ttu-id="b34ae-241">ソース スクリプトや行番号などの元の実行情報を保持するために、例外を再スローできます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-241">We want to re-throw the exception to preserve the original execution information like source script and line number.</span></span> <span data-ttu-id="b34ae-242">この時点で新しい例外をスローすると、例外が開始された場所が隠されてしまいます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-242">If we throw a new exception at this point, it hides where the exception started.</span></span>

#### <a name="re-throwing-a-new-exception"></a><span data-ttu-id="b34ae-243">新しい例外を再スローする</span><span class="sxs-lookup"><span data-stu-id="b34ae-243">Re-throwing a new exception</span></span>

<span data-ttu-id="b34ae-244">例外をキャッチしたが、別の例外をスローしたい場合は、元の例外を新しい例外の内側に入れ子にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-244">If you catch an exception but you want to throw a different one, then you should nest the original exception inside the new one.</span></span> <span data-ttu-id="b34ae-245">これにより、スタックのこの後で `$PSItem.Exception.InnerException` としてアクセスできるようになります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-245">This allows someone down the stack to access it as the `$PSItem.Exception.InnerException`.</span></span>

```powershell
catch
{
    throw [System.MissingFieldException]::new('Could not access field',$PSItem.Exception)
}
```

#### <a name="pscmdletthrowterminatingerror"></a><span data-ttu-id="b34ae-246">$PSCmdlet.ThrowTerminatingError()</span><span class="sxs-lookup"><span data-stu-id="b34ae-246">$PSCmdlet.ThrowTerminatingError()</span></span>

<span data-ttu-id="b34ae-247">未処理の例外に対して `throw` を使用することの問題の 1 つは、エラー メッセージが `throw` ステートメントを指し、その行が問題であることを示すことです。</span><span class="sxs-lookup"><span data-stu-id="b34ae-247">The one thing that I don't like about using `throw` for raw exceptions is that the error message points at the `throw` statement and indicates that line is where the problem is.</span></span>

```Output
Unable to find the specified file.
At line:31 char:9
+         throw [System.IO.FileNotFoundException]::new()
+         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (:) [], FileNotFoundException
    + FullyQualifiedErrorId : Unable to find the specified file.
```

<span data-ttu-id="b34ae-248">31 行目で `throw` を呼び出したためにスクリプトが失敗したと通知するエラー メッセージは、スクリプトのユーザーに対して表示する適切なメッセージではありません。</span><span class="sxs-lookup"><span data-stu-id="b34ae-248">Having the error message tell me that my script is broken because I called `throw` on line 31 is a bad message for users of your script to see.</span></span> <span data-ttu-id="b34ae-249">これは役に立つものではありません。</span><span class="sxs-lookup"><span data-stu-id="b34ae-249">It doesn't tell them anything useful.</span></span>

<span data-ttu-id="b34ae-250">Dexter Dhami 氏が、`ThrowTerminatingError()` を使用してこれを訂正できることを指摘しました。</span><span class="sxs-lookup"><span data-stu-id="b34ae-250">Dexter Dhami pointed out that I can use `ThrowTerminatingError()` to correct that.</span></span>

```powershell
$PSCmdlet.ThrowTerminatingError(
    [System.Management.Automation.ErrorRecord]::new(
        ([System.IO.FileNotFoundException]"Could not find $Path"),
        'My.ID',
        [System.Management.Automation.ErrorCategory]::OpenError,
        $MyObject
    )
)
```

<span data-ttu-id="b34ae-251">`ThrowTerminatingError()` が `Get-Resource` と呼ばれる関数の内部で呼び出されたと仮定した場合、このエラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="b34ae-251">If we assume that `ThrowTerminatingError()` was called inside a function called `Get-Resource`, then this is the error that we would see.</span></span>

```Output
Get-Resource : Could not find C:\Program Files (x86)\Reference
Assemblies\Microsoft\Framework\.NETPortable\v4.6\System.IO.xml
At line:6 char:5
+     Get-Resource -Path $Path
+     ~~~~~~~~~~~~
    + CategoryInfo          : OpenError: (:) [Get-Resource], FileNotFoundException
    + FullyQualifiedErrorId : My.ID,Get-Resource
```

<span data-ttu-id="b34ae-252">問題の原因として `Get-Resource` 関数を指していることが確認できます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-252">Do you see how it points to the `Get-Resource` function as the source of the problem?</span></span> <span data-ttu-id="b34ae-253">これはユーザーにとって役立つ情報です。</span><span class="sxs-lookup"><span data-stu-id="b34ae-253">That tells the user something useful.</span></span>

<span data-ttu-id="b34ae-254">`$PSItem` は `ErrorRecord` であるため、この方法で `ThrowTerminatingError` を使用して再スローすることもできます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-254">Because `$PSItem` is an `ErrorRecord`, we can also use `ThrowTerminatingError` this way to re-throw.</span></span>

```powershell
catch
{
    $PSCmdlet.ThrowTerminatingError($PSItem)
}
```

<span data-ttu-id="b34ae-255">これにより、エラーの原因がコマンドレットに変更され、コマンドレットのユーザーに対して関数の内部が非表示になります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-255">This changes the source of the error to the Cmdlet and hide the internals of your function from the users of your Cmdlet.</span></span>

## <a name="try-can-create-terminating-errors"></a><span data-ttu-id="b34ae-256">Try で終了エラーが作成される場合がある</span><span class="sxs-lookup"><span data-stu-id="b34ae-256">Try can create terminating errors</span></span>

<span data-ttu-id="b34ae-257">Kirk Munro 氏は、一部の例外は `try/catch` ブロック内で実行された場合に単なる終了エラーとなることを指摘しています。</span><span class="sxs-lookup"><span data-stu-id="b34ae-257">Kirk Munro points out that some exceptions are only terminating errors when executed inside a `try/catch` block.</span></span> <span data-ttu-id="b34ae-258">これは、0 除算のランタイム例外を生成する例です。</span><span class="sxs-lookup"><span data-stu-id="b34ae-258">Here is the example he gave me that generates a divide by zero runtime exception.</span></span>

```powershell
function Start-Something { 1/(1-1) }
```

<span data-ttu-id="b34ae-259">次に、これを以下のように呼び出して、エラーが生成され、メッセージも出力されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="b34ae-259">Then invoke it like this to see it generate the error and still output the message.</span></span>

```powershell
&{ Start-Something; Write-Output "We did it. Send Email" }
```

<span data-ttu-id="b34ae-260">しかし、同じコードを `try/catch` 内に配置すると、別の現象が発生します。</span><span class="sxs-lookup"><span data-stu-id="b34ae-260">But by placing that same code inside a `try/catch`, we see something else happen.</span></span>

```powershell
try
{
    &{ Start-Something; Write-Output "We did it. Send Email" }
}
catch
{
    Write-Output "Notify Admin to fix error and send email"
}
```

<span data-ttu-id="b34ae-261">エラーが終了エラーになり、最初のメッセージが出力されないことがわかります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-261">We see the error become a terminating error and not output the first message.</span></span> <span data-ttu-id="b34ae-262">何が問題かというと、このコードを関数に含めることができるが、`try/catch` が使用されると動作が異なるということです。</span><span class="sxs-lookup"><span data-stu-id="b34ae-262">What I don't like about this one is that you can have this code in a function and it acts differently if someone is using a `try/catch`.</span></span>

<span data-ttu-id="b34ae-263">私自身はこの問題に遭遇したことはありませんが、注意が必要なコーナー ケースです。</span><span class="sxs-lookup"><span data-stu-id="b34ae-263">I have not ran into issues with this myself but it is corner case to be aware of.</span></span>

### <a name="pscmdletthrowterminatingerror-inside-trycatch"></a><span data-ttu-id="b34ae-264">try/catch 内の $PSCmdlet.ThrowTerminatingError()</span><span class="sxs-lookup"><span data-stu-id="b34ae-264">$PSCmdlet.ThrowTerminatingError() inside try/catch</span></span>

<span data-ttu-id="b34ae-265">`$PSCmdlet.ThrowTerminatingError()` の特別な点の 1 つは、コマンドレット内では終了エラーが作成されるが、コマンドレットから出た後は、終了しないエラーに変わるということです。</span><span class="sxs-lookup"><span data-stu-id="b34ae-265">One nuance of `$PSCmdlet.ThrowTerminatingError()` is that it creates a terminating error within your Cmdlet but it turns into a non-terminating error after it leaves your Cmdlet.</span></span> <span data-ttu-id="b34ae-266">これにより、エラーの処理方法を決定するのは、関数の呼び出し元の責任になります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-266">This leaves the burden on the caller of your function to decide how to handle the error.</span></span> <span data-ttu-id="b34ae-267">`-ErrorAction Stop` を使用するか `try{...}catch{...}` 内から呼び出すことによって、終了エラーに戻すことができます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-267">They can turn it back into a terminating error by using `-ErrorAction Stop` or calling it from within a `try{...}catch{...}`.</span></span>

### <a name="public-function-templates"></a><span data-ttu-id="b34ae-268">パブリック関数のテンプレート</span><span class="sxs-lookup"><span data-stu-id="b34ae-268">Public function templates</span></span>

<span data-ttu-id="b34ae-269">Kirk Munro 氏との会話の中で得られた最後の重要な点は、すべての高度な関数のすべての `begin`、`process`、および `end` ブロックの周りに `try{...}catch{...}` を配置することです。</span><span class="sxs-lookup"><span data-stu-id="b34ae-269">One last take a way I had with my conversation with Kirk Munro was that he places a `try{...}catch{...}` around every `begin`, `process` and `end` block in all of his advanced functions.</span></span> <span data-ttu-id="b34ae-270">これらの汎用 catch ブロックでは、`$PSCmdlet.ThrowTerminatingError($PSItem)` を使用する単一行により、関数を離れるすべての例外を処理します。</span><span class="sxs-lookup"><span data-stu-id="b34ae-270">In those generic catch blocks, he has a single line using `$PSCmdlet.ThrowTerminatingError($PSItem)` to deal with all exceptions leaving his functions.</span></span>

```powershell
function Start-Something
{
    [CmdletBinding()]
    param()

    process
    {
        try
        {
            ...
        }
        catch
        {
            $PSCmdlet.ThrowTerminatingError($PSItem)
        }
    }
}
```

<span data-ttu-id="b34ae-271">すべてが関数の `try` ステートメント内にあるため、すべてが一貫して動作します。</span><span class="sxs-lookup"><span data-stu-id="b34ae-271">Because everything is in a `try` statement within his functions, everything acts consistently.</span></span> <span data-ttu-id="b34ae-272">これにより、生成されたエラーから内部コードを非表示にするクリーンなエラーもエンド ユーザーに提供されます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-272">This also gives clean errors to the end user that hides the internal code from the generated error.</span></span>

## <a name="trap"></a><span data-ttu-id="b34ae-273">Trap</span><span class="sxs-lookup"><span data-stu-id="b34ae-273">Trap</span></span>

<span data-ttu-id="b34ae-274">ここでは、例外の `try/catch` の側面について重点的に取り上げました。</span><span class="sxs-lookup"><span data-stu-id="b34ae-274">I focused on the `try/catch` aspect of exceptions.</span></span> <span data-ttu-id="b34ae-275">しかし、最後に、あるレガシ機能について説明する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-275">But there's one legacy feature I need to mention before we wrap this up.</span></span>

<span data-ttu-id="b34ae-276">`trap` は、スクリプトまたは関数内に配置され、そのスコープで発生するすべての例外をキャッチします。</span><span class="sxs-lookup"><span data-stu-id="b34ae-276">A `trap` is placed in a script or function to catch all exceptions that happen in that scope.</span></span> <span data-ttu-id="b34ae-277">例外が発生すると、`trap` 内のコードが実行され、その後、通常のコードが続行されます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-277">When an exception happens, the code in the `trap` is executed and then the normal code continues.</span></span> <span data-ttu-id="b34ae-278">複数の例外が発生した場合、trap は何度も呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b34ae-278">If multiple exceptions happen, then the trap is called over and over.</span></span>

```powershell
trap
{
    Write-Log $PSItem.ToString()
}

throw [System.Exception]::new('first')
throw [System.Exception]::new('second')
throw [System.Exception]::new('third')
```

<span data-ttu-id="b34ae-279">個人的にはこの方法を採用したことはありませんが、発生した例外をすべてログに記録し、その後実行を継続する管理者またはコントローラーのスクリプトでは、価値がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-279">I personally never adopted this approach but I can see the value in admin or controller scripts that log any and all exceptions, then still continue to execute.</span></span>

## <a name="closing-remarks"></a><span data-ttu-id="b34ae-280">最後に</span><span class="sxs-lookup"><span data-stu-id="b34ae-280">Closing remarks</span></span>

<span data-ttu-id="b34ae-281">スクリプトに適切な例外処理を追加すると、安定性が向上するだけでなく、これらの例外のトラブルシューティングも容易になります。</span><span class="sxs-lookup"><span data-stu-id="b34ae-281">Adding proper exception handling to your scripts not only make them more stable, but also makes it easier for you to troubleshoot those exceptions.</span></span>

<span data-ttu-id="b34ae-282">`throw` についてたくさんの時間を割いたのは、例外処理について話をする際の中核となる概念であるためです。</span><span class="sxs-lookup"><span data-stu-id="b34ae-282">I spent a lot of time talking `throw` because it is a core concept when talking about exception handling.</span></span> <span data-ttu-id="b34ae-283">PowerShell には、`throw` を使用するすべての状況を処理できる `Write-Error` も用意されています。</span><span class="sxs-lookup"><span data-stu-id="b34ae-283">PowerShell also gave us `Write-Error` that handles all the situations where you would use `throw`.</span></span> <span data-ttu-id="b34ae-284">そのため、これを読んだ後に `throw` を使用することが必須だとは考えないでください。</span><span class="sxs-lookup"><span data-stu-id="b34ae-284">So don't think that you need to be using `throw` after reading this.</span></span>

<span data-ttu-id="b34ae-285">例外処理について詳細に説明してきましたが、私は `Write-Error -Stop` を使用してコードでエラーを生成する方法に切り替える予定です。</span><span class="sxs-lookup"><span data-stu-id="b34ae-285">Now that I have taken the time to write about exception handling in this detail, I'm going to switch over to using `Write-Error -Stop` to generate errors in my code.</span></span> <span data-ttu-id="b34ae-286">また、Kirk 氏のアドバイスに従って、すべての関数に対して `ThrowTerminatingError` をメインの例外ハンドラーにします。</span><span class="sxs-lookup"><span data-stu-id="b34ae-286">I'm also going to take Kirk's advice and make `ThrowTerminatingError` my goto exception handler for every function.</span></span>

<!-- link references -->
[powershellexplained.com]: https://powershellexplained.com/
[オリジナル バージョン]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[original version]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[Reddit/r/PowerShell コミュニティ]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[Reddit/r/PowerShell community]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[.NET 例外の巨大な一覧]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[The big list of .NET exceptions]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[FileNotFoundException]: https://docs.microsoft.com/dotnet/api/System.IO.FileNotFoundException
[.NET ドキュメント]: https://docs.microsoft.com/dotnet/api.
[.NET documentation]: https://docs.microsoft.com/dotnet/api
